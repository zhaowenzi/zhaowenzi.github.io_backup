<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mose&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/f1266f6cd87918a7b6e13775e623d448</icon>
  <subtitle>Think Deeper &amp; Work Harder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaoziwen.com.cn/"/>
  <updated>2019-06-25T03:26:13.759Z</updated>
  <id>https://zhaoziwen.com.cn/</id>
  
  <author>
    <name>z2w</name>
    <email>me@zhaoziwen.com.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K-d树</title>
    <link href="https://zhaoziwen.com.cn/archives/dd2863c4.html"/>
    <id>https://zhaoziwen.com.cn/archives/dd2863c4.html</id>
    <published>2019-06-25T03:24:50.000Z</published>
    <updated>2019-06-25T03:26:13.759Z</updated>
    
    <content type="html"><![CDATA[<p>k-d树是在k维（k-dimensional）欧几里得空间组织点的数据结构。k-d树可以使用在多种应用场合，如多维键值搜索（例如范围搜索及最邻近搜索），是二叉空间划分树的一个特例。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>k-d树是每个结点均为k维数值点的二叉树，其上的每个结点代表一个超平面，该超平面垂直于当前划分维度的坐标轴，并在该维度上将空间划分为两部分，一部分在其左子树，另一部分在其右子树。</p><h3 id="树的构建"><a href="#树的构建" class="headerlink" title="树的构建"></a>树的构建</h3><p>平衡的k-d树的所有叶子结点到根结点的距离近视相等。但平衡的k-d树对最近邻搜索、空间搜索等应用场景并非是最优的。</p><p>常规的k-d树的构建过程为：循环依序取数据点的各维度来作为切分维度，取数据点在该维度的中值作为切分超平面，将中值左侧的数据点挂在其左子树，将中值右侧的数据点挂在其右子树。递归处理其子树，直至所有数据点挂载完毕。</p><h4 id="切分维度选择优化"><a href="#切分维度选择优化" class="headerlink" title="切分维度选择优化"></a>切分维度选择优化</h4><p>构建开始前，对比数据点在各维度的分布情况，数据点在某一维度坐标值的方差越大分布越分散，越小分布越集中。从方差大的维度开始切分可以取得很好的切分效果及平衡性。</p><h4 id="中值选择优化"><a href="#中值选择优化" class="headerlink" title="中值选择优化"></a>中值选择优化</h4><p>第一种在算法开始前，对原始数据点在所有维度进行一次排序，存储下来，然后在后续的中值选择中，无须每次都对子集进行排序</p><p>第二种从原始数据点中随机选择固定数目的点，然后对其进行排序，每次从这些样本中取中值，来作为分割超平面。</p><p>本文采用第一种方法，以二维平面(x, y)的集合(2, 3)，(5, 4)，(9, 6)，(4, 7)，(8, 1)，(9,6)为例说明构建过程。</p><ol><li>构建根结点时， 此时的切分维度为x，如上点集合在x维从小到大排序为(2, 3)，(4, 7)，(5, 4)，(7, 2)，(8, 1)，(9, 6)；其中值为(7, 2)。</li><li>(2, 3)，(4, 7)，(5, 4)挂在(7, 2)结点的左子树，(8, 1)，(9, 6)挂在(7, 2)结点的右子树。</li><li>构建(7, 2)结点的左子树时，点集合(2, 3)，(4, 7)，(5, 4)此时的切分维度为y，中值为(5, 4)作为分割平面，(2, 3)挂在其左子树，(4, 7)挂在右子树。</li><li>构建(7, 2)结点的右子树时，点集合(8, 1)，(9, 6)此时的切分维度也为y，中值为(9, 6)作为分割平面，(8, 1)挂在其左子树。至此k-d树构建完成。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190624220717.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上述k-d树也是一个二维平面逐步划分的过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190624220821.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在三维空间中k-d树的构建及空间划分过程如下：</p><p>首先，边框为红色的竖直平面将整个平面划分为两部分，这两部分又分别被边框为绿色的水平平面划分为上下两部分。最后这四个子空间又分别被边框为蓝色的竖直平面分割为两部分，变成8个子空间，这8个子空间即为叶子结点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190624221201.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="构建代码"><a href="#构建代码" class="headerlink" title="构建代码"></a>构建代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kd_tree</span><span class="params">(points, depth)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="number">0</span> == len(points):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  cutting_dim = depth % len(points[<span class="number">0</span>])</span><br><span class="line">  medium_index = len(points) // <span class="number">2</span></span><br><span class="line">  points.sort(key = itemgetter(cutting_dim))</span><br><span class="line">  node = Node(points[medium_index])</span><br><span class="line">  node.left = kd_tree(points[:medium_index], depth + <span class="number">1</span>)</span><br><span class="line">  node.right = kd_tree(points[medium_index + <span class="number">1</span>:], depth + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h4 id="寻找d维最小坐标点"><a href="#寻找d维最小坐标点" class="headerlink" title="寻找d维最小坐标点"></a>寻找d维最小坐标点</h4><h5 id="若当前结点的切分维度是d"><a href="#若当前结点的切分维度是d" class="headerlink" title="若当前结点的切分维度是d"></a>若当前结点的切分维度是d</h5><p>因其右子树结点均大于等于当前结点在d维的坐标值，所以可以忽略其右子树，仅在其左子树进行搜索。若无左子树，当前结点即是最小坐标值结点。</p><h5 id="若当前结点的切分维度不是d"><a href="#若当前结点的切分维度不是d" class="headerlink" title="若当前结点的切分维度不是d"></a>若当前结点的切分维度不是d</h5><p>需在其左子树与右子树分别进行递归搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findmin</span><span class="params">(n, depth, cutting_dim, min)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> min <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    min = n.location</span><br><span class="line">  <span class="keyword">if</span> n <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">  current_cutting_dim = depth % len(min)</span><br><span class="line">  <span class="keyword">if</span> n.location[cutting_dim] &lt; min[cutting_dim]:</span><br><span class="line">    min = n.location</span><br><span class="line">  <span class="keyword">if</span> cutting_dim == current_cutting_dim:</span><br><span class="line">    <span class="keyword">return</span> findmin(n.left, depth + <span class="number">1</span>, cutting_dim, min)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    leftmin = findmin(n.left, depth + <span class="number">1</span>, cutting_dim, min)</span><br><span class="line">    rightmin = findmin(n.right, depth + <span class="number">1</span>, cutting_dim, min)</span><br><span class="line">    <span class="keyword">if</span> leftmin[cutting_dim] &gt; rightmin[cutting_dim]:</span><br><span class="line">      <span class="keyword">return</span> rightmin</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> leftmin</span><br></pre></td></tr></table></figure><h4 id="新增结点"><a href="#新增结点" class="headerlink" title="新增结点"></a>新增结点</h4><p>从根结点出发，若待插入结点在当前结点切分维度的坐标值小于当前结点在该维度的坐标值时，在其左子树插入；若大于等于当前结点在该维度的坐标值时，在其右子树插入。递归插入，直至叶子结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(n, point, depth)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> Node(point)</span><br><span class="line">  cutting_dim = depth % len(point)</span><br><span class="line">  <span class="keyword">if</span> point[cutting_dim] &lt; n.location[cutting_dim]:</span><br><span class="line">    <span class="keyword">if</span> n.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      n.left = Node(point)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      insert(n.left, point, depth + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> n.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      n.right = Node(point)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      insert(n.right, point, depth + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>多次插入结点会导致树的不平衡，当不平衡性超过某一阈值时，需要进行再调整</p><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><h5 id="无子树"><a href="#无子树" class="headerlink" title="无子树"></a>无子树</h5><p>直接删除</p><h5 id="有右子树"><a href="#有右子树" class="headerlink" title="有右子树"></a>有右子树</h5><p>在T.right寻找x切分维度最小的结点p，然后替换被删结点T；递归删除结点p。</p><h5 id="无右子树有左子树"><a href="#无右子树有左子树" class="headerlink" title="无右子树有左子树"></a>无右子树有左子树</h5><p>在T.left寻找x切分维度最小的结点p，即p=findmin(T.left, cutting-dim=x)，然后用结点p替换被删除结点T；将原T.left作为p.right；递归处理删除结点p。</p><p>之所以未采用findmax(T.left, cutting-dim=x)结点来替换被删结点，是由于原被删结点的左子树存在x维度最大值相等的情形，这样就破坏了左子树在x分割维度的坐标需小于其根结点的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(n, point, depth)</span>:</span></span><br><span class="line">  cutting_dim = depth % len(point)</span><br><span class="line">  <span class="keyword">if</span> n.location = point:</span><br><span class="line">    <span class="keyword">if</span> n.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      n.location = findmin(n.right + <span class="number">1</span>, cutting_dim, <span class="literal">None</span>)</span><br><span class="line">      delete(n.right, n.location, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> n.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      n.location = findmin(n.left, depth + <span class="number">1</span>)</span><br><span class="line">      delete(n.left, n.location, depth + <span class="number">1</span>)</span><br><span class="line">      n.right = n.left</span><br><span class="line">      n.left = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      n = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> point[cutting_dim] &lt; n.location[cutting_dim]:</span><br><span class="line">      delete(n.left, point, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      delete(n.right, point, depth + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="最近邻搜索"><a href="#最近邻搜索" class="headerlink" title="最近邻搜索"></a>最近邻搜索</h3><p>如在上文构建好的k-d树上搜索(3, 5)的最近邻时：</p><ol><li>首先从根结点(7, 2)出发，将当前最近邻设为(7, 2)，对该k-d树作深度优先遍历。以(3， 5)为圆心，其到(7, 2)的距离为半径画圆，可以看出(8, 1)右侧的区域与该圆不相交，所以(8, 1)的右子树全部忽略。</li><li>接着走到(7, 2)左子树根结点(5, 4)，与原最近邻距离对比后，更新当前最邻近(5, 4)。以(3, 5)为圆心，其到(5, 4)的距离为半径画圆，(7, 2)右侧的区域与该圆不想交，忽略该侧所有结点，即(7, 2)的整个右子树被标记为已忽略。</li><li>遍历完(5, 4)的左右叶子结点，发现与当前最优距离相等，不更新最邻近。所以(3, 5)的最邻近为(5, 4)</li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>操作</th><th>平均复杂度</th><th>最坏复杂度</th></tr></thead><tbody><tr><td>新增结点</td><td>$O(logn)$</td><td>$O(n)$</td></tr><tr><td>删除结点</td><td>$O(logn)$</td><td>$O(n)$</td></tr><tr><td>最近邻搜索</td><td>$O(logn)$</td><td>$O(n)$</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leileiluoluo.com/posts/kdtree-algorithm-and-implementation.html" rel="external nofollow noopener noreferrer" target="_blank">k-d tree算法原理及实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;k-d树是在k维（k-dimensional）欧几里得空间组织点的数据结构。k-d树可以使用在多种应用场合，如多维键值搜索（例如范围搜索及最邻近搜索），是二叉空间划分树的一个特例。&lt;/p&gt;
&lt;h3 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树结构" scheme="https://zhaoziwen.com.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>APUE 第一章 UNIX基础知识</title>
    <link href="https://zhaoziwen.com.cn/archives/a47d4271.html"/>
    <id>https://zhaoziwen.com.cn/archives/a47d4271.html</id>
    <published>2019-06-23T04:32:51.000Z</published>
    <updated>2019-06-23T04:37:26.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h3><p>从严格意义上说，可以将操作系统定义为一种叫做内核（kernel）的软件，它控制计算机资源，提供程序运行环境。</p><p>内核的接口被称为<em>系统调用（system call）</em>。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="登录名"><a href="#登录名" class="headerlink" title="登录名"></a>登录名</h4><p>登录UNIX系统是一次键入登录名和口令。口令文件（<code>/etc/passwd</code>）中的登录项由7个冒号分隔的字段组成，依次为：登录名、加密口令（转移到另一个文件中）、数字用户ID、数字组ID、注释字段、起始目录以及shell程序</p><p><code>sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh</code></p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell是一个命令解释器，它读取用户输入，然后执行脚本。</p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>UNIX文件系统是目录和文件的一种层次结构，所有东西的七点都是称为根（root）的目录，这个目录的名称是一个字符<code>/</code>。</p><p>目录是一个包含目录项的文件。</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>斜线<code>/</code>和空字符不能出现在文件名中。斜线用来分隔构成路径名的各文件夹，空字符用来终止一个路径名。</p><p>创建新目录是会自动创建两个文件名：<code>.</code>和<code>..</code>。点指向当前目录，点点指向父目录。</p><h4 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h4><p>以斜线开头的路径称为<em>绝对路径名（absolute pathname）</em>，否则称为<em>相对路径名（relative pathname）</em>。</p><p>下面的代码实现了<code>ls</code>的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: ls directory_name"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">        </span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h4><p>每个进程都有一个工作目录（working directory，又称为当前工作目录）。所有相对路径名都是从工作目录开始解释。进程可以使用<code>chdir</code>函数更改工作目录。</p><h4 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h4><p>登录时，工作目录设置为起始目录（home directory），该起始目录从口令文件中相应用户的登录项中取得。</p><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符通常是一个<em>小的非负整数</em>，内核用以标识一个特定进程正在访问的文件。当内核打开一个文件或创建一个新文件时，都返回一个文件描述符，它可以用来读、写。</p><h4 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h4><p>每当运行一个新程序是，所有的shell都为其打开3个文件描述符，即<em>标准输入</em>、<em>标准输出</em>和<em>标准错误</em>。如果不做特殊处理，这3个描述符都链接向终端。大多数shell都可以是任何一个或这3个描述符重定向到某个文件，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; file.list</span><br></pre></td></tr></table></figure><h4 id="不带缓冲的I-O"><a href="#不带缓冲的I-O" class="headerlink" title="不带缓冲的I/O"></a>不带缓冲的I/O</h4><p>函数<code>open</code>、<code>read</code>、<code>write</code>、<code>lseek</code>和<code>close</code>提供了不带缓冲的I/O，这些函数都使用文件描述符。</p><p>下面的程序从标准输入读，并向标准输出写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(<span class="string">"write error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h4><p>标注I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。</p><p>下面的程序是使用标准I/O的版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c = getc(<span class="built_in">stdin</span>)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (putc(c, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">            err_sys(<span class="string">"output error"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ferror(<span class="built_in">stdin</span>))</span><br><span class="line">        err_sys(<span class="string">"input error"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p>程序是一个存储在磁盘上某个目录中的可执行文件。内核使用<code>exec</code>函数，将程序读入内存，并执行程序。</p><h4 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h4><p>程序的执行实例被称为进程。每个进程都有一个唯一的数字标识符，称为进程ID。</p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>有3个用于进程控制的主要函数：<code>fork</code>、<code>exex</code>、<code>waitpid</code>。</p><h4 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h4><p>一个进程内的所有线程共享同一地址空间、文件描述符、栈以及和进程相关的属性。线程ID只在它所属的进程内起作用</p><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><p>UNIX系统出错是，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值。多个线程共享进程地址空间，每个线程都有属于自己的局部errno。</p><ol><li>如果没有出错，其值不会被历程清除。</li><li>任何函数都不会讲errno值设置为0。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><p><code>strerror</code>函数将errnum映射为一个出错消息字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>perror</code>函数基于errno的当前值，在标准错误上产生一条出错消息，然后返回。</p><p>它首先输出msg指向的字符串，然后是一个冒号，一个空格，接着是对应于errno值的出错消息，最后是一个换行符。</p><p>使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"EACCES: %s\n"</span>, strerror(EACCESS));</span><br><span class="line">    errno = ENOENT;</span><br><span class="line">    perror(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h3><h4 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h4><p>用户ID（user ID）是一个数值，向系统标识各个不同的用户。用户ID为0的用户为根用户（root）或超级用户（superuser）。</p><h4 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h4><p>在口令文件中有多个登录项具有相同的组ID。组被用于将若干用户集合到项目或部门中，以允许同组的各个成员之间共享资源。</p><p>打印用户ID和组ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid = %d, gid = %d\n"</span>, getuid(), getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h4><p>它允许一个用户属于多至16个其他的组。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号（signal）用于通知进程发生了某种情况。</p><p>处理方式有三种：</p><ol><li>忽略信号。</li><li>按系统默认方式处理。</li><li>提供一个函数，信号发生时调用该函数。</li></ol><p>终端键盘上有两种产生信号的方法，分别为中断键（interrupt key，通常是<code>Delete</code>键或<code>Ctrl + C</code>）和退出键（quit key，通常是<code>ctrl + \</code>）。</p><p>下面的程序捕捉中断键，并调用对应函数，只是打印一条消息，然后打印一个新提示符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">            err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sig_int(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h3><p>UNIX使用两种不同的时间值：</p><ol><li>日历时间。该值是自1970年1月1日 00:00:00以来所经过的秒数累计值。系统基本数据类型<code>time_t</code>用于保存这种时间值。</li><li>进程时间。也被称为CPU时间，用以度量进程使用的CPU资源。进程时间以始终滴答计算。每秒曾经取值为50、60或100个时钟滴答。系统基本数据类型<code>clock_t</code>保存这种时间值。</li></ol><p>当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：</p><ul><li>时钟时间</li><li>用户CPU时间</li><li>系统CPU时间</li></ul><p>时钟时间又称为<em>墙上时钟时间（wall clock time）</em>，它是进程运行的时间总量，其值与系统中同时运行的进程数有关。</p><p>用户CPU时间是执行用户指令所用的时间量。系统CPU时间是为该进程执行内核程序所经历的时间。合称为CPU时间。</p><h3 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h3><p>UNIX都提供良好定义、数量有限、直接进入内核的入口点，称为<em>系统调用（system call）</em>。</p><p>通用库函数可能会调用一个或多个内核的系统调用，但它们不是内核的入口点。</p><p>应用程序既可以调用系统调用也可以调用库函数。</p><h3 id="习题答案"><a href="#习题答案" class="headerlink" title="习题答案"></a>习题答案</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><p>利用<code>ls</code>命令中的下面两个选择项：</p><p>-i：显示文件或目录的i结点数目</p><p>-d：如果参数是一目录，只列出其名字，而不是目录中的所有文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190623122422.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><p>UNIX是多任务系统，在程序运行的同时其他两个进程也在运行</p><h4 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h4><p>perror的msg参数是个指针，perror就可以改变msg指向的字符串。然而使用限定const限制了perror不能修改msg指针指向的字符串。</p><p>而对于strerror，其错误号参数是整数类型，并且C是按值传递参数，所有strerror函数修改不了函数外的值，所以没有必要使用const限定。</p><h4 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h4><p>2038年。将time_t数据类型定义为64位整型。</p><h4 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h4><p>$$t = 2^{32} / (60 * 60 * 24 * 100) = 248.551348天$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;UNIX体系结构&quot;&gt;&lt;a href=&quot;#UNIX体系结构&quot; class=&quot;headerlink&quot; title=&quot;UNIX体系结构&quot;&gt;&lt;/a&gt;UNIX体系结构&lt;/h3&gt;&lt;p&gt;从严格意义上说，可以将操作系统定义为一种叫做内核（kernel）的软件，它控制计算机资源，提
      
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://zhaoziwen.com.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="apue" scheme="https://zhaoziwen.com.cn/tags/apue/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://zhaoziwen.com.cn/archives/9439fc83.html"/>
    <id>https://zhaoziwen.com.cn/archives/9439fc83.html</id>
    <published>2019-06-17T11:01:58.000Z</published>
    <updated>2019-06-18T04:11:39.029Z</updated>
    
    <content type="html"><![CDATA[<p>B树，又称B-树，是一种是用于外查找（在磁盘或其他存储设备中查找）的多叉树</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li><p>每个结点 x 有下面属性</p><ol><li>x.n，当前存储在结点x中的关键字个数</li><li>x.n 个关键字本身$x.key_{1}$，$x.key_{2}$，$x.key_{3}$，…，$x.key_{x.n}$以非降序存放</li><li>x.leaf，一个布尔值，如果x是叶节点，则为TRUE；如果x是内部结点，则为FALSE</li></ol></li><li><p>每个内部结点x还包含 x.n+1 个指向其孩子的指针$x.c_{1}$，$x.c_{2}$，… ，$x.c_{n+1}$。叶结点没有孩子</p></li><li><p>关键字$x.key_{i}$对存储在各子树中的关键字范围加以分割：如果$k_{i}$为任意一个存储在以$x.c_{i}$为根的子树中的关键字，那么</p><p>$$k_{1} ≤ x.key_{1} ≤ k_{2} ≤ x.key_{2} ≤ … ≤ x.key_{x.n} ≤ k_{x.n+1}$$</p></li><li><p>每个叶节点具有相同的深度，即树的高度h</p></li><li><p>每个结点所包含的关键字个数有上界和下界。用一个被称为B树的最小度数（minmum degree）的固定整数 $t≥2$ 来表示这些界：</p><ol><li>除了根结点以外的每个结点必须至少有t-1个关键字。因此，除了根结点以外的每个内部结点至少有t个孩子。如果树非空，根结点至少有一个关键字</li><li>每个结点至多可包含2t-1个关键字。因此，一个内部结点至多可有2t个孩子。当一个结点恰好有2t-1个关键字时，称该结点是满的</li></ol></li></ol><p>t=2时的B树是最简单的。每个内部结点有2个、3个或者4个孩子，即一棵2-3-4树。一般t值越大，B树的高度就越小</p><h4 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h4><p>B数上的大部分操作所需的磁盘存储次数与B树的高度成正比。</p><p>如果$n≥1$，那么对任意一棵包含n个关键字、高度为h、最小度数$t≥2$的B树T，有：</p><p>$$h \leqslant \log _{t} \frac{n+1}{2}$$</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="搜索B树"><a href="#搜索B树" class="headerlink" title="搜索B树"></a>搜索B树</h4><p>对每个内部结点x，做的是一个（x, n+1）路的分支选择</p><p>B-TREE-SEARCH的输入是一个指向某子树根结点x的指针，以及要在该子树中搜索的一个关键字k。因此，顶层调用的形式为B-TREE-SEARCH（T.root, k）。如果B-TREE-SEARCH返回的是结点y和使得$y.key_{i}=k$的下标i组成的有序对（y, i）；否则，过程返回NIL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-SEARCH(x,k)</span><br><span class="line">  i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt;= x.n <span class="keyword">and</span> k &gt; x.key(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> i ≤ x.n <span class="keyword">and</span> k == x.key(i)</span><br><span class="line">    <span class="keyword">return</span> (x, i)</span><br><span class="line">  elseif x.leaf</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">  <span class="keyword">else</span> DISK-READ(x, c(i))</span><br><span class="line">    <span class="keyword">return</span> B-TREE-SEARCH(x.c(i), k)</span><br></pre></td></tr></table></figure><p>第2-4行找出最小下标i，使得$k≤x.key_{i}$，若找不到，则置i为x.n+1。第5-6行检查是否已经找到关键字，如果找到，则返回；否则，第7-10行结束不成功查找（如果x是叶结点），或者在对孩子结点执行必要的DISK-READ后，递归搜索x的相应子树。因此，有B-TREE-SEARCH过程访问的磁盘页面数为$O(h)=O\left(\log _{t} n\right)$，总的CPU时间为$O(t h)=O\left(t \log _{t} n\right)$</p><h4 id="向B树中插入一个关键字"><a href="#向B树中插入一个关键字" class="headerlink" title="向B树中插入一个关键字"></a>向B树中插入一个关键字</h4><p>首先需要查找插入新关键字的叶结点的位置。然后将新的关键字插入一个已经存在的叶结点上。由于不能将关键字插入一个满的叶结点，故需要将一个满的结点y（有2t-1个关键字）按其中间关键字$y.key_{t}$分裂为两个各含t-1个关键字的结点。中间关键字被提升到y的父节点。如果y的父节点也是满的，就必须在插入新的关键字之前将其分裂，最终满结点的分裂会沿着树向上传播</p><h4 id="分裂B树中的结点"><a href="#分裂B树中的结点" class="headerlink" title="分裂B树中的结点"></a>分裂B树中的结点</h4><p>要分裂一个满的根，首先要让根成为一个新的空根结点的孩子，这样才能使用B-TREE-SPLIT-CHILD。树的高度因此增加1；分裂是树长高的唯一途径</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190618114953.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-SPLIT-CHILD(x, i)</span><br><span class="line">z = ALLOCATE-NODE()</span><br><span class="line">y = x.c(i)</span><br><span class="line">z.leaf = y.leaf</span><br><span class="line">x.n = t - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to t - <span class="number">1</span></span><br><span class="line">  z.key(j) = y.key(j+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> y.leaf</span><br><span class="line">  <span class="keyword">for</span> j = i to t</span><br><span class="line">    z.c(j) = y.c(j+t)</span><br><span class="line">y.n = t - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j = x.n + <span class="number">1</span> downto i + <span class="number">1</span></span><br><span class="line">  x.c(j+<span class="number">1</span>) = x.c(j)</span><br><span class="line">x.c(i+<span class="number">1</span>) = z</span><br><span class="line"><span class="keyword">for</span> j = x.n downto i</span><br><span class="line">  x.key(j+<span class="number">1</span>) = x.key(j)</span><br><span class="line">x.key(i) = y.key(t)</span><br><span class="line">x.n = x.n + <span class="number">1</span></span><br><span class="line">DISK-WRITE(y)</span><br><span class="line">DISK-WRITE(z)</span><br><span class="line">DISK-WRITE(x)</span><br></pre></td></tr></table></figure><h4 id="从B树中删除关键字"><a href="#从B树中删除关键字" class="headerlink" title="从B树中删除关键字"></a>从B树中删除关键字</h4><ol><li>如果关键字k在结点x中，并且x是叶结点，则从x中删除k</li><li>如果关键字k再结点x中，并且x是内部结点，则做以下操作：<ol><li>如果结点x中前于k的子节点y至少包含t个关键字，则找出k在以y为根的子树中的前驱k’。递归地删除k’，并在x中用k’代替k</li><li>对称地，如果y有少于t个关键字，则检查结点x中后与k的子节点z。如果z至少有t个关键字，则找出k在以z为根的子树中的后继k’。递归地删除k’，并在x中用k’代替k</li><li>否则，如果y和z都只含有t-1个关键字，则将k和z的全部合并进y，这样x就失去了k和指向z的指针，并且y现在包含2t-1个关键字。然后释放z并递归地从y中删除k</li></ol></li><li>如果关键字k当前不在内部结点x中，则确定必包含k的子树的根$x.c_{i}$（如果k确实在树中）。如果$x.c_{i}$只有t-1个关键字，必须执行步骤3-1或者3-2来保证降至一个至少包含t个关键字的结点。然后，通过对x的某个合适的子节点进行递归而结束<ol><li>如果$x.c_{i}$只含有t-1个关键字，但还它的一个相邻的兄弟至少包含t个关键字，则将x中的某一个关键字降至$x.c_{i}$中，将$x.c_{i}$的相邻左兄弟或右兄弟的一个关键字升至x，将该兄弟中相应的孩子指针移到$x.c_{i}$中，这样就使得$x.c_{i}$增加了一个额外的关键字</li><li>如果$x.c_{i}$以及$x.c_{i}$的所有相邻兄弟都只包含t-1个关键字，则将$x.c_{i}$与一个兄弟合并，即将x的一个关键字移至新合并的结点，使之成为该结点的中间关键字</li></ol></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190618120350.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;B树，又称B-树，是一种是用于外查找（在磁盘或其他存储设备中查找）的多叉树&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;h4 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; cl
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树结构" scheme="https://zhaoziwen.com.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2-3查找树与红黑树（Java）</title>
    <link href="https://zhaoziwen.com.cn/archives/4a7356f9.html"/>
    <id>https://zhaoziwen.com.cn/archives/4a7356f9.html</id>
    <published>2019-06-15T18:02:28.000Z</published>
    <updated>2019-06-17T07:22:08.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><p>一棵2-3查找树或为一棵空树，或由以下结点组成：</p><ul><li>2- 结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点</li><li>3- 结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点</li></ul><p>其余查找、插入以及一些性质点击链接查看 <a href="https://algs4.cs.princeton.edu/33balanced/" rel="external nofollow noopener noreferrer" target="_blank"><strong>2-3 search trees</strong></a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种特殊的二叉查找树，并其同时也是2-3查找树的一种简单实现。红黑二叉查找树是想用标准的二叉查找树加一些额外的信息来表示2-3树。红链接将两个2- 结点连接起来构成一个3- 结点，黑链接则是2-3树中的普通链接。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190613013325.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>同时，满足以下条件的二叉查找树即为红黑树</p><ul><li>红链接均为左链接（左偏红黑树）</li><li>没有任何一个结点同时和两条红链接相连</li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li></ul><h4 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h4><p>将链接的颜色保存在表示结点的Node数据类型的布尔变量中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615170355.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>用旋转的方法来解决红色右链接或者两条连续的红链接</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615170927.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a left-leaning link lean to the right</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">  Node x = h.left;</span><br><span class="line">  h.left = x.right;</span><br><span class="line">  x.right = h;</span><br><span class="line">  x.color = x.right.color;</span><br><span class="line">  x.right.color = RED;</span><br><span class="line">  x.size = h.size;</span><br><span class="line">  h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">  Node x = h.right;</span><br><span class="line">  h.right = x.left;</span><br><span class="line">  x.left = h;</span><br><span class="line">  x.color = x.left.color;</span><br><span class="line">  x.left.color = RED;</span><br><span class="line">  x.size = h.size;</span><br><span class="line">  h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="颜色转换"><a href="#颜色转换" class="headerlink" title="颜色转换"></a>颜色转换</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615171118.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flip the colors of a node and its two children</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// h must have opposite color of its two children</span></span><br><span class="line">  <span class="comment">// assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);</span></span><br><span class="line">  <span class="comment">// assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))</span></span><br><span class="line">  <span class="comment">//    || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));</span></span><br><span class="line">  h.color = !h.color;</span><br><span class="line">  h.left.color = !h.left.color;</span><br><span class="line">  h.right.color = !h.right.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><h5 id="向2-结点中插入新键（单个结点）"><a href="#向2-结点中插入新键（单个结点）" class="headerlink" title="向2- 结点中插入新键（单个结点）"></a>向2- 结点中插入新键（单个结点）</h5><p>一颗只含有一个键的红黑树只含有一个2- 结点。</p><ul><li>如果新键小于老键。只需要新增一个红色结点即可</li><li>如果新键大于老键。新增的红色结点会产生一个红色的右链接，需要使用root = rotateLeft(root)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/QQ20190615-172606.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="向树底部的2-结点插入新键"><a href="#向树底部的2-结点插入新键" class="headerlink" title="向树底部的2- 结点插入新键"></a>向树底部的2- 结点插入新键</h5><p>用和二叉查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个结点，但总是用红链接将新结点和它的父结点相连。处理方式与上述处理方式相同</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615173153.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="向一棵双键树（即一个3-结点）中插入新键"><a href="#向一棵双键树（即一个3-结点）中插入新键" class="headerlink" title="向一棵双键树（即一个3- 结点）中插入新键"></a>向一棵双键树（即一个3- 结点）中插入新键</h5><p>分为三种子情况，每种情况都会产生一个同时连接到两条红链接的结点</p><ul><li>新键大于原树中的两个键。因此被连接到3- 结点的右链接。此时只需要将两条链接的颜色都由红变黑即可。</li><li>新键小于原树中的两个键。它会被连接到最左边的空链接，即产生了两条连续的红链接。此时只需要将上层的红链接右旋转即可得到第一种情况。</li><li>新键介于原树中的两个键。也会产生两条连续的红链接，一条红色左链接接一条红色右链接。此时只需要将下层的红链接坐旋转即可得到第二种情况。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615174628.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="向树底部的3-结点插入新键"><a href="#向树底部的3-结点插入新键" class="headerlink" title="向树底部的3- 结点插入新键"></a>向树底部的3- 结点插入新键</h5><p>颜色转换会使到中结点的链接变红，相当于将它送入了父结点。然后对父结点继续处理。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615174954.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>总之，使用左旋转、右旋转和颜色转换这三个操作就能保证插入操作后红黑树和2-3树的一一对应关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，就能完成插入操作：</p><ul><li>如果右子结点是红色的而左子节点是黑色的，进行左旋转；</li><li>如果左子结点是红色的且他的左子结点也是红色的，进行右旋转；</li><li>如果左右子结点均为红色，进行颜色转换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> *  Red-black tree insertion.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Inserts the specified key-value pair into the symbol table, overwriting the old </span></span><br><span class="line"><span class="comment">  * value with the new value if the symbol table already contains the specified key.</span></span><br><span class="line"><span class="comment">  * Deletes the specified key (and its associated value) from this symbol table</span></span><br><span class="line"><span class="comment">  * if the specified value is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> val the value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to put() is null"</span>);</span><br><span class="line">     <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">         delete(key);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     root = put(root, key, val);</span><br><span class="line">     root.color = BLACK;</span><br><span class="line">     <span class="comment">// assert check();</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// insert the key-value pair in the subtree rooted at h</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, Key key, Value val)</span> </span>&#123; </span><br><span class="line">     <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">     <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) h.left  = put(h.left,  key, val); </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right, key, val); </span><br><span class="line">     <span class="keyword">else</span>              h.val   = val;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// fix-up any right-leaning links</span></span><br><span class="line">     <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      h = rotateLeft(h);</span><br><span class="line">     <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) h = rotateRight(h);</span><br><span class="line">     <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     flipColors(h);</span><br><span class="line">     h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> h;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="删除最小键"><a href="#删除最小键" class="headerlink" title="删除最小键"></a>删除最小键</h5><p>从树底部的3- 结点中删除键是很简单的，但2- 结点则不然。从2- 结点删除一个键而留下的空结点会破坏树的完美平衡性。为了保证不会删除一个2- 结点，我们沿着左链接向下进行变换，确保当前结点不是2- 结点（可能是3- 结点，也可能是临时的4- 结点）。如果根是2- 结点且它的两个子结点都是2- 结点。则可以直接将三个结点变成一个4- 结点，否则需要保证根结点的左子结点不是2- 结点，如有必要可以从它的右侧的兄弟结点借一个键。</p><ul><li>如果当前结点的左子结点不是2- 结点，完成；</li><li>如果当前结点的左子结点是2- 结点而它的亲兄弟结点不是2- 结点，将左子结点的兄弟结点中的一个键移动到左子结点中；</li><li>如果当前结点的左子结点和它的亲兄弟结点都是2- 结点，将左子结点、父节点中的最小键和左子结点最近的兄弟结点合并为一个4- 结点，是父节点由3- 结点变为2- 结点或者由4- 结点变为3- 结点。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190615185825.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3- 结点或者4- 结点，然后直接从中将其删除，将3- 结点变为2- 结点，或者将4- 结点变为3- 结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"BST underflow"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if both children of root are black, set root to red</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</span><br><span class="line">        root.color = RED;</span><br><span class="line"></span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">    <span class="comment">// assert check();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete the key-value pair with the minimum key rooted at h</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node h)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (h.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 找到了最小的，删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前结点不是3- 结点并且它的左孩子也不是一个3- 结点，需要调整</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</span><br><span class="line">        h = moveRedLeft(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归删除</span></span><br><span class="line">    h.left = deleteMin(h.left);</span><br><span class="line">    <span class="comment">// 借键以及融合过程中产生连续的以及右斜的红链接需要调整</span></span><br><span class="line">    <span class="keyword">return</span> balance(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assuming that h is red and both h.left and h.left.left</span></span><br><span class="line"><span class="comment">// are black, make h.left or one of its children red.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">moveRedLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert (h != null);</span></span><br><span class="line">    <span class="comment">// assert isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.left.left);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 融合当前结点，左孩子、右孩子为新的4- 结点</span></span><br><span class="line">    flipColors(h);</span><br><span class="line">    <span class="comment">// 如果右孩子是3- 结点，这个时候需要上述的借键给左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right.left)) &#123; </span><br><span class="line">        h.right = rotateRight(h.right);</span><br><span class="line">        h = rotateLeft(h);</span><br><span class="line">        flipColors(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assuming that h is red and both h.right and h.right.left</span></span><br><span class="line"><span class="comment">// are black, make h.right or one of its children red.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">moveRedRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert (h != null);</span></span><br><span class="line">    <span class="comment">// assert isRed(h) &amp;&amp; !isRed(h.right) &amp;&amp; !isRed(h.right.left);</span></span><br><span class="line">    flipColors(h);</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left.left)) &#123; </span><br><span class="line">        h = rotateRight(h);</span><br><span class="line">        flipColors(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flip the colors of a node and its two children</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// h must have opposite color of its two children</span></span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);</span></span><br><span class="line">    <span class="comment">// assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))</span></span><br><span class="line">    <span class="comment">//    || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));</span></span><br><span class="line">    h.color = !h.color;</span><br><span class="line">    h.left.color = !h.left.color;</span><br><span class="line">    h.right.color = !h.right.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除最大键"><a href="#删除最大键" class="headerlink" title="删除最大键"></a>删除最大键</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the largest key and associated value from the symbol table.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"BST underflow"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if both children of root are black, set root to red</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</span><br><span class="line">        root.color = RED;</span><br><span class="line"></span><br><span class="line">    root = deleteMax(root);</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">    <span class="comment">// assert check();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete the key-value pair with the maximum key rooted at h</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node h)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left))</span><br><span class="line">        h = rotateRight(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</span><br><span class="line">        h = moveRedRight(h);</span><br><span class="line"></span><br><span class="line">    h.right = deleteMax(h.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> balance(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除指定键"><a href="#删除指定键" class="headerlink" title="删除指定键"></a>删除指定键</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the specified key and its associated value from this symbol table     </span></span><br><span class="line"><span class="comment"> * (if the key is in this symbol table).    </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to delete() is null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!contains(key)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if both children of root are black, set root to red</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</span><br><span class="line">        root.color = RED;</span><br><span class="line"></span><br><span class="line">    root = delete(root, key);</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">    <span class="comment">// assert check();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete the key-value pair with the given key rooted at h</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node h, Key key)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// assert get(h, key) != null;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(h.key) &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</span><br><span class="line">            h = moveRedLeft(h);</span><br><span class="line">        h.left = delete(h.left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left))</span><br><span class="line">            h = rotateRight(h);</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span> &amp;&amp; (h.right == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</span><br><span class="line">            h = moveRedRight(h);</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span>) &#123;</span><br><span class="line">            Node x = min(h.right);</span><br><span class="line">            h.key = x.key;</span><br><span class="line">            h.val = x.val;</span><br><span class="line">            <span class="comment">// h.val = get(h.right, min(h.right).key);</span></span><br><span class="line">            <span class="comment">// h.key = min(h.right).key;</span></span><br><span class="line">            h.right = deleteMin(h.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> h.right = delete(h.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整实现（Java）"><a href="#完整实现（Java）" class="headerlink" title="完整实现（Java）"></a>完整实现（Java）</h4><h5 id="红黑树源码"><a href="#红黑树源码" class="headerlink" title="红黑树源码"></a>红黑树源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;     <span class="comment">// root of the BST</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BST helper node data type</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;           <span class="comment">// key</span></span><br><span class="line">        <span class="keyword">private</span> Value val;         <span class="comment">// associated data</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;  <span class="comment">// links to left and right subtrees</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> color;     <span class="comment">// color of parent link</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;          <span class="comment">// subtree count</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">boolean</span> color, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes an empty symbol table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedBlackBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Node helper methods.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line">    <span class="comment">// is node x red; false if x is null ?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> x.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of node in subtree rooted at x; 0 if x is null</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value pairs in this symbol table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value pairs in this symbol table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is this symbol table empty?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this symbol table is empty and &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Standard BST search.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value associated with the given key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value associated with the given key if the key is in the symbol table</span></span><br><span class="line"><span class="comment">     *     and &#123;<span class="doctag">@code</span> null&#125; if the key is not in the symbol table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to get() is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value associated with the given key in subtree rooted at x; null if no such key</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">            <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) x = x.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x = x.right;</span><br><span class="line">            <span class="keyword">else</span>              <span class="keyword">return</span> x.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does this symbol table contain the given key?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this symbol table contains &#123;<span class="doctag">@code</span> key&#125; and</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Red-black tree insertion.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified key-value pair into the symbol table, overwriting the old </span></span><br><span class="line"><span class="comment">     * value with the new value if the symbol table already contains the specified key.</span></span><br><span class="line"><span class="comment">     * Deletes the specified key (and its associated value) from this symbol table</span></span><br><span class="line"><span class="comment">     * if the specified value is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val the value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to put() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">            delete(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = put(root, key, val);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">        <span class="comment">// assert check();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert the key-value pair in the subtree rooted at h</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, Key key, Value val)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) h.left  = put(h.left,  key, val); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right, key, val); </span><br><span class="line">        <span class="keyword">else</span>              h.val   = val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fix-up any right-leaning links</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      h = rotateLeft(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) h = rotateRight(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     flipColors(h);</span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Red-black tree deletion.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the smallest key and associated value from the symbol table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"BST underflow"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if both children of root are black, set root to red</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</span><br><span class="line">            root.color = RED;</span><br><span class="line"></span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">        <span class="comment">// assert check();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the key-value pair with the minimum key rooted at h</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node h)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (h.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</span><br><span class="line">            h = moveRedLeft(h);</span><br><span class="line"></span><br><span class="line">        h.left = deleteMin(h.left);</span><br><span class="line">        <span class="keyword">return</span> balance(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the largest key and associated value from the symbol table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"BST underflow"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if both children of root are black, set root to red</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</span><br><span class="line">            root.color = RED;</span><br><span class="line"></span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">        <span class="comment">// assert check();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the key-value pair with the maximum key rooted at h</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node h)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left))</span><br><span class="line">            h = rotateRight(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</span><br><span class="line">            h = moveRedRight(h);</span><br><span class="line"></span><br><span class="line">        h.right = deleteMax(h.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> balance(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the specified key and its associated value from this symbol table     </span></span><br><span class="line"><span class="comment">     * (if the key is in this symbol table).    </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to delete() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!contains(key)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if both children of root are black, set root to red</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right))</span><br><span class="line">            root.color = RED;</span><br><span class="line"></span><br><span class="line">        root = delete(root, key);</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">        <span class="comment">// assert check();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the key-value pair with the given key rooted at h</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node h, Key key)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// assert get(h, key) != null;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(h.key) &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</span><br><span class="line">                h = moveRedLeft(h);</span><br><span class="line">            h.left = delete(h.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRed(h.left))</span><br><span class="line">                h = rotateRight(h);</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span> &amp;&amp; (h.right == <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</span><br><span class="line">                h = moveRedRight(h);</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span>) &#123;</span><br><span class="line">                Node x = min(h.right);</span><br><span class="line">                h.key = x.key;</span><br><span class="line">                h.val = x.val;</span><br><span class="line">                <span class="comment">// h.val = get(h.right, min(h.right).key);</span></span><br><span class="line">                <span class="comment">// h.key = min(h.right).key;</span></span><br><span class="line">                h.right = deleteMin(h.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> h.right = delete(h.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Red-black tree helper functions.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// make a left-leaning link lean to the right</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">        Node x = h.left;</span><br><span class="line">        h.left = x.right;</span><br><span class="line">        x.right = h;</span><br><span class="line">        x.color = x.right.color;</span><br><span class="line">        x.right.color = RED;</span><br><span class="line">        x.size = h.size;</span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">        Node x = h.right;</span><br><span class="line">        h.right = x.left;</span><br><span class="line">        x.left = h;</span><br><span class="line">        x.color = x.left.color;</span><br><span class="line">        x.left.color = RED;</span><br><span class="line">        x.size = h.size;</span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flip the colors of a node and its two children</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// h must have opposite color of its two children</span></span><br><span class="line">        <span class="comment">// assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);</span></span><br><span class="line">        <span class="comment">// assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))</span></span><br><span class="line">        <span class="comment">//    || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));</span></span><br><span class="line">        h.color = !h.color;</span><br><span class="line">        h.left.color = !h.left.color;</span><br><span class="line">        h.right.color = !h.right.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assuming that h is red and both h.left and h.left.left</span></span><br><span class="line">    <span class="comment">// are black, make h.left or one of its children red.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">moveRedLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert (h != null);</span></span><br><span class="line">        <span class="comment">// assert isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.left.left);</span></span><br><span class="line"></span><br><span class="line">        flipColors(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right.left)) &#123; </span><br><span class="line">            h.right = rotateRight(h.right);</span><br><span class="line">            h = rotateLeft(h);</span><br><span class="line">            flipColors(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assuming that h is red and both h.right and h.right.left</span></span><br><span class="line">    <span class="comment">// are black, make h.right or one of its children red.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">moveRedRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert (h != null);</span></span><br><span class="line">        <span class="comment">// assert isRed(h) &amp;&amp; !isRed(h.right) &amp;&amp; !isRed(h.right.left);</span></span><br><span class="line">        flipColors(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left.left)) &#123; </span><br><span class="line">            h = rotateRight(h);</span><br><span class="line">            flipColors(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore red-black tree invariant</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">balance</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert (h != null);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right))                      h = rotateLeft(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right))     flipColors(h);</span><br><span class="line"></span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Utility functions.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the height of the BST (for debugging).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the height of the BST (a 1-node tree has height 0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(x.left), height(x.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Ordered symbol table methods.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the smallest key in the symbol table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the smallest key in the symbol table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls min() with empty symbol table"</span>);</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// the smallest key in subtree rooted at x; null if no such key</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x; </span><br><span class="line">        <span class="keyword">else</span>                <span class="keyword">return</span> min(x.left); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the largest key in the symbol table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the largest key in the symbol table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls max() with empty symbol table"</span>);</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// the largest key in the subtree rooted at x; null if no such key</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x; </span><br><span class="line">        <span class="keyword">else</span>                 <span class="keyword">return</span> max(x.right); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the largest key in the symbol table less than or equal to &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the largest key in the symbol table less than or equal to &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if there is no such key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to floor() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls floor() with empty symbol table"</span>);</span><br><span class="line">        Node x = floor(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span>           <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// the largest key in the subtree rooted at x less than or equal to the given key</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">        Node t = floor(x.right, key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t; </span><br><span class="line">        <span class="keyword">else</span>           <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the smallest key in the symbol table greater than or equal to &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the smallest key in the symbol table greater than or equal to &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if there is no such key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to ceiling() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls ceiling() with empty symbol table"</span>);</span><br><span class="line">        Node x = ceiling(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span>           <span class="keyword">return</span> x.key;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the smallest key in the subtree rooted at x greater than or equal to the given key</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, Key key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)  <span class="keyword">return</span> ceiling(x.right, key);</span><br><span class="line">        Node t = ceiling(x.left, key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t; </span><br><span class="line">        <span class="keyword">else</span>           <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the key in the symbol table whose rank is &#123;<span class="doctag">@code</span> k&#125;.</span></span><br><span class="line"><span class="comment">     * This is the (k+1)st smallest key in the symbol table. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  k the order statistic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the key in the symbol table of rank &#123;<span class="doctag">@code</span> k&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> k&#125; is between 0 and</span></span><br><span class="line"><span class="comment">     *        &lt;em&gt;n&lt;/em&gt;–1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to select() is invalid: "</span> + k);</span><br><span class="line">        &#125;</span><br><span class="line">        Node x = select(root, k);</span><br><span class="line">        <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the key of rank k in the subtree rooted at x</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="comment">// assert k &gt;= 0 &amp;&amp; k &lt; size(x);</span></span><br><span class="line">        <span class="keyword">int</span> t = size(x.left); </span><br><span class="line">        <span class="keyword">if</span>      (t &gt; k) <span class="keyword">return</span> select(x.left,  k); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) <span class="keyword">return</span> select(x.right, k-t-<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">else</span>            <span class="keyword">return</span> x; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of keys in the symbol table strictly less than &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of keys in the symbol table strictly less than &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to rank() is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> rank(key, root);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of keys less than key in the subtree rooted at x</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key); </span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, x.left); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(key, x.right); </span><br><span class="line">        <span class="keyword">else</span>              <span class="keyword">return</span> size(x.left); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Range count and range search.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns all keys in the symbol table as an &#123;<span class="doctag">@code</span> Iterable&#125;.</span></span><br><span class="line"><span class="comment">     * To iterate over all of the keys in the symbol table named &#123;<span class="doctag">@code</span> st&#125;,</span></span><br><span class="line"><span class="comment">     * use the foreach notation: &#123;<span class="doctag">@code</span> for (Key key : st.keys())&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all keys in the symbol table as an &#123;<span class="doctag">@code</span> Iterable&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">        <span class="keyword">return</span> keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns all keys in the symbol table in the given range,</span></span><br><span class="line"><span class="comment">     * as an &#123;<span class="doctag">@code</span> Iterable&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  lo minimum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  hi maximum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all keys in the sybol table between &#123;<span class="doctag">@code</span> lo&#125; </span></span><br><span class="line"><span class="comment">     *    (inclusive) and &#123;<span class="doctag">@code</span> hi&#125; (inclusive) as an &#123;<span class="doctag">@code</span> Iterable&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if either &#123;<span class="doctag">@code</span> lo&#125; or &#123;<span class="doctag">@code</span> hi&#125;</span></span><br><span class="line"><span class="comment">     *    is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to keys() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (hi == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"second argument to keys() is null"</span>);</span><br><span class="line"></span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">        <span class="comment">// if (isEmpty() || lo.compareTo(hi) &gt; 0) return queue;</span></span><br><span class="line">        keys(root, queue, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// add the keys between lo and hi in the subtree rooted at x</span></span><br><span class="line">    <span class="comment">// to the queue</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">        <span class="keyword">int</span> cmplo = lo.compareTo(x.key); </span><br><span class="line">        <span class="keyword">int</span> cmphi = hi.compareTo(x.key); </span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt; <span class="number">0</span>) keys(x.left, queue, lo, hi); </span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt;= <span class="number">0</span> &amp;&amp; cmphi &gt;= <span class="number">0</span>) queue.enqueue(x.key); </span><br><span class="line">        <span class="keyword">if</span> (cmphi &gt; <span class="number">0</span>) keys(x.right, queue, lo, hi); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of keys in the symbol table in the given range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  lo minimum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  hi maximum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of keys in the sybol table between &#123;<span class="doctag">@code</span> lo&#125; </span></span><br><span class="line"><span class="comment">     *    (inclusive) and &#123;<span class="doctag">@code</span> hi&#125; (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if either &#123;<span class="doctag">@code</span> lo&#125; or &#123;<span class="doctag">@code</span> hi&#125;</span></span><br><span class="line"><span class="comment">     *    is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to size() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (hi == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"second argument to size() is null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.compareTo(hi) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (contains(hi)) <span class="keyword">return</span> rank(hi) - rank(lo) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>              <span class="keyword">return</span> rank(hi) - rank(lo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment">    *  Check integrity of red-black tree data structure.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isBST())            StdOut.println(<span class="string">"Not in symmetric order"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isSizeConsistent()) StdOut.println(<span class="string">"Subtree counts not consistent"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isRankConsistent()) StdOut.println(<span class="string">"Ranks not consistent"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!is23())             StdOut.println(<span class="string">"Not a 2-3 tree"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isBalanced())       StdOut.println(<span class="string">"Not balanced"</span>);</span><br><span class="line">        <span class="keyword">return</span> isBST() &amp;&amp; isSizeConsistent() &amp;&amp; isRankConsistent() &amp;&amp; is23() &amp;&amp; isBalanced();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// does this binary tree satisfy symmetric order?</span></span><br><span class="line">    <span class="comment">// Note: this test also ensures that data structure is a binary tree since order is strict</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the tree rooted at x a BST with all keys strictly between min and max</span></span><br><span class="line">    <span class="comment">// (if min or max is null, treat as empty constraint)</span></span><br><span class="line">    <span class="comment">// Credit: Bob Dondero's elegant solution</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node x, Key min, Key max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; x.key.compareTo(min) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; x.key.compareTo(max) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(x.left, min, x.key) &amp;&amp; isBST(x.right, x.key, max);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// are the size fields correct?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSizeConsistent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isSizeConsistent(root); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSizeConsistent</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.size != size(x.left) + size(x.right) + <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSizeConsistent(x.left) &amp;&amp; isSizeConsistent(x.right);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that ranks are consistent</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRankConsistent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (i != rank(select(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Key key : keys())</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(select(rank(key))) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Does the tree have no red right links, and at most one (left)</span></span><br><span class="line">    <span class="comment">// red links in a row on any path?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">is23</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> is23(root); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">is23</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (isRed(x.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x != root &amp;&amp; isRed(x) &amp;&amp; isRed(x.left))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> is23(x.left) &amp;&amp; is23(x.right);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// do all paths from root to leaf have same number of black edges?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> black = <span class="number">0</span>;     <span class="comment">// number of black links on path from root to min</span></span><br><span class="line">        Node x = root;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isRed(x)) black++;</span><br><span class="line">            x = x.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root, black);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// does every path from the root to a leaf have the given number of black links?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node x, <span class="keyword">int</span> black)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> black == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isRed(x)) black--;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(x.left, black) &amp;&amp; isBalanced(x.right, black);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unit tests the &#123;<span class="doctag">@code</span> RedBlackBST&#125; data type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        RedBlackBST&lt;String, Integer&gt; st = <span class="keyword">new</span> RedBlackBST&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !StdIn.isEmpty(); i++) &#123;</span><br><span class="line">            String key = StdIn.readString();</span><br><span class="line">            st.put(key, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s : st.keys())</span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s));</span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedBlackBST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String test = <span class="string">"S E A R C H E X A M P L E"</span>; </span><br><span class="line">        String[] keys = test.split(<span class="string">" "</span>); </span><br><span class="line">        RedBlackBST&lt;String, Integer&gt; st = <span class="keyword">new</span> RedBlackBST&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.length; i++) </span><br><span class="line">            st.put(keys[i], i); </span><br><span class="line"></span><br><span class="line">        StdOut.println(<span class="string">"size = "</span> + st.size());</span><br><span class="line">        StdOut.println(<span class="string">"min  = "</span> + st.min());</span><br><span class="line">        StdOut.println(<span class="string">"max  = "</span> + st.max());</span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// print keys in order using allKeys()</span></span><br><span class="line">        StdOut.println(<span class="string">"Testing keys()"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : st.keys()) </span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s)); </span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print keys in order using select</span></span><br><span class="line">        StdOut.println(<span class="string">"Testing select"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st.size(); i++)</span><br><span class="line">            StdOut.println(i + <span class="string">" "</span> + st.select(i)); </span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test rank, floor, ceiling</span></span><br><span class="line">        StdOut.println(<span class="string">"key rank floor ceil"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'A'</span>; i &lt;= <span class="string">'Z'</span>; i++) &#123;</span><br><span class="line">            String s = i + <span class="string">""</span>;</span><br><span class="line">            StdOut.printf(<span class="string">"%2s %4d %4s %4s\n"</span>, s, st.rank(s), st.floor(s), st.ceiling(s));</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test range search and range count</span></span><br><span class="line">        String[] from = &#123; <span class="string">"A"</span>, <span class="string">"Z"</span>, <span class="string">"X"</span>, <span class="string">"0"</span>, <span class="string">"B"</span>, <span class="string">"C"</span> &#125;;</span><br><span class="line">        String[] to   = &#123; <span class="string">"Z"</span>, <span class="string">"A"</span>, <span class="string">"X"</span>, <span class="string">"Z"</span>, <span class="string">"G"</span>, <span class="string">"L"</span> &#125;;</span><br><span class="line">        StdOut.println(<span class="string">"range search"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; from.length; i++) &#123;</span><br><span class="line">            StdOut.printf(<span class="string">"%s-%s (%2d) : "</span>, from[i], to[i], st.size(from[i], to[i]));</span><br><span class="line">            <span class="keyword">for</span> (String s : st.keys(from[i], to[i]))</span><br><span class="line">                StdOut.print(s + <span class="string">" "</span>);</span><br><span class="line">            StdOut.println();</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delete the smallest keys</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st.size() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            st.deleteMin();</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(<span class="string">"After deleting the smallest "</span> + st.size() / <span class="number">2</span> + <span class="string">" keys"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : st.keys()) </span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s)); </span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delete all the remaining keys</span></span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">            st.delete(st.select(st.size() / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(<span class="string">"After deleting the remaining keys"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : st.keys()) </span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s)); </span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        StdOut.println(<span class="string">"After adding back n keys"</span>);</span><br><span class="line">        StdOut.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.length; i++) </span><br><span class="line">            st.put(keys[i], i); </span><br><span class="line">        <span class="keyword">for</span> (String s : st.keys()) </span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s)); </span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert N elements in order if one command-line argument supplied</span></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        RedBlackBST&lt;Integer, Integer&gt; st2 = <span class="keyword">new</span> RedBlackBST&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            st2.put(i, i);</span><br><span class="line">            <span class="keyword">int</span> h = st2.height();</span><br><span class="line">            StdOut.println(<span class="string">"i = "</span> + i + <span class="string">", height = "</span> + h + <span class="string">", size = "</span> + st2.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delete keys in random order</span></span><br><span class="line">        StdOut.println(<span class="string">"Deleting keys in random order"</span>);</span><br><span class="line">        <span class="keyword">while</span> (st2.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = StdRandom.uniform(n);</span><br><span class="line">            <span class="keyword">if</span> (st2.contains(i)) &#123;</span><br><span class="line">                st2.delete(i);</span><br><span class="line">                <span class="keyword">int</span> h = st2.height();</span><br><span class="line">                StdOut.println(<span class="string">"i = "</span> + i + <span class="string">", height = "</span> + h + <span class="string">", size = "</span> + st2.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StdOut.println(<span class="string">"size = "</span> + st2.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">size = 10</span><br><span class="line">min  = A</span><br><span class="line">max  = X</span><br><span class="line"></span><br><span class="line">Testing keys()</span><br><span class="line">--------------------------------</span><br><span class="line">A 8</span><br><span class="line">C 4</span><br><span class="line">E 12</span><br><span class="line">H 5</span><br><span class="line">L 11</span><br><span class="line">M 9</span><br><span class="line">P 10</span><br><span class="line">R 3</span><br><span class="line">S 0</span><br><span class="line">X 7</span><br><span class="line"></span><br><span class="line">Testing select</span><br><span class="line">--------------------------------</span><br><span class="line">0 A</span><br><span class="line">1 C</span><br><span class="line">2 E</span><br><span class="line">3 H</span><br><span class="line">4 L</span><br><span class="line">5 M</span><br><span class="line">6 P</span><br><span class="line">7 R</span><br><span class="line">8 S</span><br><span class="line">9 X</span><br><span class="line"></span><br><span class="line">key rank floor ceil</span><br><span class="line">-------------------</span><br><span class="line"> A    0    A    A</span><br><span class="line"> B    1    A    C</span><br><span class="line"> C    1    C    C</span><br><span class="line"> D    2    C    E</span><br><span class="line"> E    2    E    E</span><br><span class="line"> F    3    E    H</span><br><span class="line"> G    3    E    H</span><br><span class="line"> H    3    H    H</span><br><span class="line"> I    4    H    L</span><br><span class="line"> J    4    H    L</span><br><span class="line"> K    4    H    L</span><br><span class="line"> L    4    L    L</span><br><span class="line"> M    5    M    M</span><br><span class="line"> N    6    M    P</span><br><span class="line"> O    6    M    P</span><br><span class="line"> P    6    P    P</span><br><span class="line"> Q    7    P    R</span><br><span class="line"> R    7    R    R</span><br><span class="line"> S    8    S    S</span><br><span class="line"> T    9    S    X</span><br><span class="line"> U    9    S    X</span><br><span class="line"> V    9    S    X</span><br><span class="line"> W    9    S    X</span><br><span class="line"> X    9    X    X</span><br><span class="line"> Y   10    X null</span><br><span class="line"> Z   10    X null</span><br><span class="line"></span><br><span class="line">range search</span><br><span class="line">-------------------</span><br><span class="line">A-Z (10) : A C E H L M P R S X </span><br><span class="line">Z-A ( 0) : </span><br><span class="line">X-X ( 1) : X </span><br><span class="line">0-Z (10) : A C E H L M P R S X </span><br><span class="line">B-G ( 2) : C E </span><br><span class="line">C-L ( 4) : C E H L </span><br><span class="line"></span><br><span class="line">After deleting the smallest 3 keys</span><br><span class="line">--------------------------------</span><br><span class="line">H 5</span><br><span class="line">L 11</span><br><span class="line">M 9</span><br><span class="line">P 10</span><br><span class="line">R 3</span><br><span class="line">S 0</span><br><span class="line">X 7</span><br><span class="line"></span><br><span class="line">After deleting the remaining keys</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line">After adding back n keys</span><br><span class="line">--------------------------------</span><br><span class="line">A 8</span><br><span class="line">C 4</span><br><span class="line">E 12</span><br><span class="line">H 5</span><br><span class="line">L 11</span><br><span class="line">M 9</span><br><span class="line">P 10</span><br><span class="line">R 3</span><br><span class="line">S 0</span><br><span class="line">X 7</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-3查找树&quot;&gt;&lt;a href=&quot;#2-3查找树&quot; class=&quot;headerlink&quot; title=&quot;2-3查找树&quot;&gt;&lt;/a&gt;2-3查找树&lt;/h3&gt;&lt;p&gt;一棵2-3查找树或为一棵空树，或由以下结点组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2- 结点，含有一个键（及其对应
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树结构" scheme="https://zhaoziwen.com.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="https://zhaoziwen.com.cn/archives/4263f441.html"/>
    <id>https://zhaoziwen.com.cn/archives/4263f441.html</id>
    <published>2019-06-11T13:27:24.000Z</published>
    <updated>2019-06-11T13:31:39.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>平衡二叉树又称AVL树，是一种特殊的二叉查找树。</p><p>性质：</p><ul><li>左右两个子树都是一颗平衡二叉树</li><li>左右两个子树的高度差的绝对值不超过1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> key;            <span class="comment">//结点的值</span></span><br><span class="line">    <span class="keyword">int</span> height;         <span class="comment">//结点的高度，根结点为0</span></span><br><span class="line">    AVLNode* left;      <span class="comment">//左孩子</span></span><br><span class="line">    AVLNode* right;     <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    AVLNode(<span class="keyword">int</span> k, AVLNode* left, AVLNode* right) :key(k), height(<span class="number">0</span>), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>当二叉树失衡的原因出现在“最低失衡根结点左子树的左子树”（所谓“最低失衡根结点”，则是从新增结点开始向根部回溯，所遇到的第一个失衡的根节点）时，则使用LL旋转来调整；当失衡出现在“最低失衡根节点左子树的右子树”，则使用LR旋转调整；RR旋转，RL旋转同理。</p><h4 id="LL旋转"><a href="#LL旋转" class="headerlink" title="LL旋转"></a>LL旋转</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611205241.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>LL旋转的对象是”最低失衡根节点”，即节点5。把该节点的左孩子的右孩子（节点4）变成该节点（5）的左孩子，然后把该节点（5）变为它的左孩子（3）的右孩子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611205610.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*LL旋转，</span></span><br><span class="line"><span class="comment">* 参数： </span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::leftLeftRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    AVLNode* lchild = root-&gt;left;</span><br><span class="line">    root-&gt;left = lchild-&gt;right;</span><br><span class="line">    lchild-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    lchild-&gt;height = max(height(lchild-&gt;left), height(root)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RR旋转"><a href="#RR旋转" class="headerlink" title="RR旋转"></a>RR旋转</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611205751.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>RR旋转的对象是”最低失衡根节点”，即节点2。把该节点的右孩子的左孩子（节点3）变成该节点（2）的右孩子，然后把该节点（2）变为它的右孩子（4）的左孩子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611205858.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RR旋转，</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::rightRightRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    AVLNode* rchild = root-&gt;right;</span><br><span class="line">    root-&gt;right = rchild-&gt;left;</span><br><span class="line">    rchild-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    rchild-&gt;height = max(height(root), height(rchild-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LR旋转"><a href="#LR旋转" class="headerlink" title="LR旋转"></a>LR旋转</h4><p>LL旋转和RR旋转只需要一次旋转即可达到平衡，而LR旋转和RL旋转才能达到平衡</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611210021.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>先对失衡节点的左孩子进行RR旋转，再对失衡节点进行LL旋转</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611210209.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*LR旋转</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::leftRightRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    root-&gt;left = rightRightRotate(root-&gt;left);    <span class="comment">//先对左子树右右旋转</span></span><br><span class="line">    <span class="keyword">return</span> leftLeftRotate(root);    <span class="comment">//再对根结点左左旋转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RL旋转"><a href="#RL旋转" class="headerlink" title="RL旋转"></a>RL旋转</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611210506.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>先对最低失衡节点右孩子LL旋转，再对最低失衡节点RR旋转</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190611210629.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RL旋转</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::rightLeftRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    root-&gt;right = leftLeftRotate(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> rightRightRotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入操作与向二叉查找树中插入基本一致，多了插入后判断二叉树是否失衡，以及失衡后的调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 参数说明：</span></span><br><span class="line"><span class="comment">*     root 插入新结点前AVL树的根结点</span></span><br><span class="line"><span class="comment">*     key 插入的结点的键值</span></span><br><span class="line"><span class="comment">* 返回值：</span></span><br><span class="line"><span class="comment">*     插入结点后AVL树的根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::insert(AVLNode* root, <span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        root = <span class="keyword">new</span> AVLNode(key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key)    <span class="comment">//插入左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;left) - height(root-&gt;right) == <span class="number">2</span>)    <span class="comment">//插入导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; root-&gt;left-&gt;key)</span><br><span class="line">                root = leftLeftRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = leftRightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&gt;root-&gt;key)        <span class="comment">//插入右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;right) - height(root-&gt;left) == <span class="number">2</span>)    <span class="comment">//插入导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; root-&gt;right-&gt;key)</span><br><span class="line">                root = rightRightRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = rightLeftRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 参数说明：</span></span><br><span class="line"><span class="comment">*     root 删除结点前AVL树的根结点</span></span><br><span class="line"><span class="comment">*     node 要删除的结点</span></span><br><span class="line"><span class="comment">* 返回值：</span></span><br><span class="line"><span class="comment">*     删除结点node后AVL树的根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::deleteNode(AVLNode* root, AVLNode* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; root-&gt;key)        <span class="comment">//要删除的结点在左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;right) - height(root-&gt;left) == <span class="number">2</span>)    <span class="comment">//删除导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLNode* rightNode = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (height(rightNode-&gt;left)&gt;height(rightNode-&gt;right))</span><br><span class="line">                root = rightLeftRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = rightRightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; root-&gt;key)    <span class="comment">//要删除的结点在右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;left) - height(root-&gt;right) == <span class="number">2</span>)    <span class="comment">//删除导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLNode* leftNode = root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (height(leftNode-&gt;left) &gt; height(leftNode-&gt;right))</span><br><span class="line">                root = leftLeftRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = leftRightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//找到了要删除的结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>&amp;&amp;root-&gt;right != <span class="literal">NULL</span>)    <span class="comment">//结点的左右子树均不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root-&gt;left) &gt; height(root-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果tree的左子树比右子树高；</span></span><br><span class="line"><span class="comment">                * 则(01)找出tree的左子树中的最大节点</span></span><br><span class="line"><span class="comment">                *  (02)将该最大节点的值赋值给tree。</span></span><br><span class="line"><span class="comment">                *  (03)删除该最大节点。</span></span><br><span class="line"><span class="comment">                * 这类似于用"tree的左子树中最大节点"做"tree"的替身；</span></span><br><span class="line"><span class="comment">                * 采用这种方式的好处是：删除"tree的左子树中最大节点"之后，AVL树仍然是平衡的。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                AVLNode* maxNode = maximus(root-&gt;left);</span><br><span class="line">                root-&gt;key = maxNode-&gt;key;</span><br><span class="line">                root-&gt;left = deleteNode(root-&gt;left, maxNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></span><br><span class="line"><span class="comment">                 * 则(01)找出tree的右子树中的最小节点</span></span><br><span class="line"><span class="comment">                 *  (02)将该最小节点的值赋值给tree。</span></span><br><span class="line"><span class="comment">                 *  (03)删除该最小节点。</span></span><br><span class="line"><span class="comment">                 * 这类似于用"tree的右子树中最小节点"做"tree"的替身；</span></span><br><span class="line"><span class="comment">                 * 采用这种方式的好处是：删除"tree的右子树中最小节点"之后，AVL树仍然是平衡的。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                AVLNode* minNode = minimus(root-&gt;right);</span><br><span class="line">                root-&gt;key = minNode-&gt;key;</span><br><span class="line">                root-&gt;right = deleteNode(root-&gt;right, minNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLNode* tmp = root;</span><br><span class="line">            root = (root-&gt;left != <span class="literal">NULL</span>) ? root-&gt;left : root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><h4 id="头文件-avltree-h"><a href="#头文件-avltree-h" class="headerlink" title="头文件 avltree.h"></a>头文件 avltree.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> key;            <span class="comment">//结点的值</span></span><br><span class="line">    <span class="keyword">int</span> height;            <span class="comment">//结点的高度，根结点为0</span></span><br><span class="line">    AVLNode* left;        <span class="comment">//左孩子</span></span><br><span class="line">    AVLNode* right;        <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    AVLNode(<span class="keyword">int</span> k, AVLNode* left, AVLNode* right) :key(k), height(<span class="number">0</span>), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLNode* root;        <span class="comment">//根节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    AVLTree() :root(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*返回根节点*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*先序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*中序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*后序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在AVL树root中查找值为key的结点并返回该结点*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">search</span><span class="params">(AVLNode* root, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在AVL树中查找最小值结点并返回*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">minimus</span><span class="params">(AVLNode* node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在AVL树中查找最大值结点并返回*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">maximus</span><span class="params">(AVLNode* node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*返回结点的高度*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(AVLNode* node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*左左旋转*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">leftLeftRotate</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*右右旋转*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">rightRightRotate</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*左右旋转*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">leftRightRotate</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*右左旋转*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">rightLeftRotate</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*插入结点*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">insert</span><span class="params">(AVLNode* root, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除结点node*/</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">deleteNode</span><span class="params">(AVLNode* root, AVLNode* node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*销毁AVL树*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(AVLNode* root)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先序遍历*/</span></span><br><span class="line"><span class="keyword">void</span> AVLTree::preOrder(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历*/</span></span><br><span class="line"><span class="keyword">void</span> AVLTree::inOrder(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后序遍历*/</span></span><br><span class="line"><span class="keyword">void</span> AVLTree::postOrder(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在AVL树root中查找值为key的结点并返回该结点*/</span></span><br><span class="line">AVLNode* AVLTree::search(AVLNode* root, <span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;key == key)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        search(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> search(root-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在AVL树中查找最小值结点并返回*/</span></span><br><span class="line">AVLNode* AVLTree::minimus(AVLNode* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> minimus(node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在AVL树中查找最大值结点并返回*/</span></span><br><span class="line">AVLNode* AVLTree::maximus(AVLNode* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> maximus(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回结点的高度*/</span></span><br><span class="line"><span class="keyword">int</span> AVLTree::height(AVLNode* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LL旋转，</span></span><br><span class="line"><span class="comment">* 参数： </span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::leftLeftRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    AVLNode* lchild = root-&gt;left;</span><br><span class="line">    root-&gt;left = lchild-&gt;right;</span><br><span class="line">    lchild-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    lchild-&gt;height = max(height(lchild-&gt;left), height(root)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*RR旋转</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::rightRightRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    AVLNode* rchild = root-&gt;right;</span><br><span class="line">    root-&gt;right = rchild-&gt;left;</span><br><span class="line">    rchild-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    rchild-&gt;height = max(height(root), height(rchild-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LR旋转</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::leftRightRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    root-&gt;left = rightRightRotate(root-&gt;left);    <span class="comment">//先对左子树右右旋转</span></span><br><span class="line">    <span class="keyword">return</span> leftLeftRotate(root);    <span class="comment">//再对根结点左左旋转</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*RL旋转</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* root ： 失衡AVL树根节点</span></span><br><span class="line"><span class="comment">* 返回值 ： 调整后的AVL树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::rightLeftRotate(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    root-&gt;right = leftLeftRotate(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> rightRightRotate(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 参数说明：</span></span><br><span class="line"><span class="comment">*     root 插入新结点前AVL树的根结点</span></span><br><span class="line"><span class="comment">*     key 插入的结点的键值</span></span><br><span class="line"><span class="comment">* 返回值：</span></span><br><span class="line"><span class="comment">*     插入结点后AVL树的根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::insert(AVLNode* root, <span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        root = <span class="keyword">new</span> AVLNode(key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key)    <span class="comment">//插入左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;left) - height(root-&gt;right) == <span class="number">2</span>)    <span class="comment">//插入二叉树导致失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; root-&gt;left-&gt;key)</span><br><span class="line">                root = leftLeftRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = leftRightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&gt;root-&gt;key)        <span class="comment">//插入右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;right) - height(root-&gt;left) == <span class="number">2</span>)    <span class="comment">//插入导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; root-&gt;right-&gt;key)</span><br><span class="line">                root = rightRightRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = rightLeftRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 参数说明：</span></span><br><span class="line"><span class="comment">*     root 删除结点前AVL树的根结点</span></span><br><span class="line"><span class="comment">*     node 要删除的结点</span></span><br><span class="line"><span class="comment">* 返回值：</span></span><br><span class="line"><span class="comment">*     删除结点node后AVL树的根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AVLNode* AVLTree::deleteNode(AVLNode* root, AVLNode* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; root-&gt;key)        <span class="comment">//要删除的结点在左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;right) - height(root-&gt;left) == <span class="number">2</span>)    <span class="comment">//删除导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLNode* rightNode = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (height(rightNode-&gt;left)&gt;height(rightNode-&gt;right))</span><br><span class="line">                root = rightLeftRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = rightRightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; root-&gt;key)    <span class="comment">//要删除的结点在右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">if</span> (height(root-&gt;left) - height(root-&gt;right) == <span class="number">2</span>)    <span class="comment">//删除导致二叉树失衡</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLNode* leftNode = root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (height(leftNode-&gt;left) &gt; height(leftNode-&gt;right))</span><br><span class="line">                root = leftLeftRotate(root);</span><br><span class="line">            <span class="keyword">else</span> root = leftRightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//找到了要删除的结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>&amp;&amp;root-&gt;right != <span class="literal">NULL</span>)    <span class="comment">//结点的左右子树均不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root-&gt;left) &gt; height(root-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果tree的左子树比右子树高；</span></span><br><span class="line"><span class="comment">                * 则(01)找出tree的左子树中的最大节点</span></span><br><span class="line"><span class="comment">                *  (02)将该最大节点的值赋值给tree。</span></span><br><span class="line"><span class="comment">                *  (03)删除该最大节点。</span></span><br><span class="line"><span class="comment">                * 这类似于用"tree的左子树中最大节点"做"tree"的替身；</span></span><br><span class="line"><span class="comment">                * 采用这种方式的好处是：删除"tree的左子树中最大节点"之后，AVL树仍然是平衡的。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                AVLNode* maxNode = maximus(root-&gt;left);</span><br><span class="line">                root-&gt;key = maxNode-&gt;key;</span><br><span class="line">                root-&gt;left = deleteNode(root-&gt;left, maxNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></span><br><span class="line"><span class="comment">                 * 则(01)找出tree的右子树中的最小节点</span></span><br><span class="line"><span class="comment">                 *  (02)将该最小节点的值赋值给tree。</span></span><br><span class="line"><span class="comment">                 *  (03)删除该最小节点。</span></span><br><span class="line"><span class="comment">                 * 这类似于用"tree的右子树中最小节点"做"tree"的替身；</span></span><br><span class="line"><span class="comment">                 * 采用这种方式的好处是：删除"tree的右子树中最小节点"之后，AVL树仍然是平衡的。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                AVLNode* minNode = minimus(root-&gt;right);</span><br><span class="line">                root-&gt;key = minNode-&gt;key;</span><br><span class="line">                root-&gt;right = deleteNode(root-&gt;right, minNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLNode* tmp = root;</span><br><span class="line">            root = (root-&gt;left != <span class="literal">NULL</span>) ? root-&gt;left : root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁二叉树*/</span></span><br><span class="line"><span class="keyword">void</span> AVLTree::destroy(AVLNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    destroy(root-&gt;left);</span><br><span class="line">    destroy(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源文件-avltree-cpp"><a href="#源文件-avltree-cpp" class="headerlink" title="源文件 avltree.cpp"></a>源文件 avltree.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"avltree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    AVLTree* avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">    AVLNode* root = avlTree-&gt;getRoot();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        root = avlTree-&gt;insert(root, a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序遍历："</span>;</span><br><span class="line">    avlTree-&gt;preOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中序遍历："</span>;</span><br><span class="line">    avlTree-&gt;inOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"后序遍历："</span>;</span><br><span class="line">    avlTree-&gt;postOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除结点4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    AVLNode* node = avlTree-&gt;search(root, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        AVLNode* dnode = avlTree-&gt;deleteNode(root, node);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除结点4后先序遍历："</span>;</span><br><span class="line">    avlTree-&gt;preOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除结点4后中序遍历："</span>;</span><br><span class="line">    avlTree-&gt;inOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁AVL树"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    avlTree-&gt;destroy(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先序遍历：7 4 2 1 3 6 5 13 11 9 8 10 12 15 14 16 </span><br><span class="line">中序遍历：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 </span><br><span class="line">后序遍历：1 3 2 5 6 4 8 10 9 12 11 14 16 15 13 7 </span><br><span class="line">删除结点4</span><br><span class="line">删除结点4后先序遍历：7 5 2 1 3 6 13 11 9 8 10 12 15 14 16 </span><br><span class="line">删除结点4后中序遍历：1 2 3 5 6 7 8 9 10 11 12 13 14 15 16 </span><br><span class="line">销毁AVL树</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/sench/p/7786718.html" rel="external nofollow noopener noreferrer" target="_blank">平衡二叉树（AVL树）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;平衡二叉树又称AVL树，是一种特殊的二叉查找树。&lt;/p&gt;
&lt;p&gt;性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左右两个子树都是一颗平衡二叉树&lt;/li&gt;

      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树结构" scheme="https://zhaoziwen.com.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速上手Alfred 4</title>
    <link href="https://zhaoziwen.com.cn/archives/7bad2533.html"/>
    <id>https://zhaoziwen.com.cn/archives/7bad2533.html</id>
    <published>2019-06-07T09:56:17.000Z</published>
    <updated>2019-06-07T10:16:09.830Z</updated>
    
    <content type="html"><![CDATA[<p>很多次看到别人在Mac上使用Alfred，终于被酷炫的操作所折服，开始鼓捣这个庞大且<del>复杂</del>（并不）的效率神器。下面记录一下整个学习使用的过程。</p><p>本文使用的是Alfred 4.0.1，付费正版（肉痛）。</p><h3 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h3><h4 id="通用（General）"><a href="#通用（General）" class="headerlink" title="通用（General）"></a>通用（General）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190605222037664.png" alt="image-20190605222037664" title>                </div>                <div class="image-caption">image-20190605222037664</div>            </figure><p>其中Startup勾选的状态为开机启动</p><p>Alfred Hotkey为呼出操作窗口的热键</p><p>Where are you为你所在的地区，避免网页搜索等打开了其他国家的网站（由于众所周知的原因，这个在国内好像并没什么吊用）</p><p>Permission为该软件运行所需要的权限，必定全选，不然感觉是个残废</p><h4 id="特性（Features）"><a href="#特性（Features）" class="headerlink" title="特性（Features）"></a>特性（Features）</h4><p>免费玩家只能用这些设定好的功能</p><h5 id="默认结果（Default-Results）"><a href="#默认结果（Default-Results）" class="headerlink" title="默认结果（Default Results）"></a>默认结果（Default Results）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190605222558642.png" alt="image-20190605222558642" title>                </div>                <div class="image-caption">image-20190605222558642</div>            </figure><ul><li><strong>Essentials:</strong> 这里可以设置搜索「设置」、「联系人」</li><li><strong>Extras:</strong> 这里还可以包含「文件夹」、「文档」、「文本文件」、「图片」、「压缩文件」、「AppleScripts」等，不过这些其实可以通过后面的文件搜索来实现，勾选之后反而会影响查询速度</li><li><strong>Unintelligent:</strong> 所有所有文件类型，同样不建议勾选，原因如上</li><li><strong>Search Scope:</strong> 搜索范围，当有外置移动硬盘时，如果需要也要将外置移动硬盘拉入其中。~Library是应用程序文件存放位置，也应排除</li><li><strong>Fallbacks:</strong> 如果搜索不到结果，改用网页搜索</li></ul><h5 id="文件搜索（File-Search）"><a href="#文件搜索（File-Search）" class="headerlink" title="文件搜索（File Search）"></a>文件搜索（File Search）</h5><h6 id="搜索（Search）选项"><a href="#搜索（Search）选项" class="headerlink" title="搜索（Search）选项"></a>搜索（Search）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190605234846544.png" alt="image-20190605234846544" title>                </div>                <div class="image-caption">image-20190605234846544</div>            </figure><ul><li><strong>Quick Search:</strong> 快速搜索，可以使用单引号或者<code>&#39;单引号</code>或者<code>Space（空格）</code>快速搜索或者打开文件</li><li><strong>Opening Files:</strong> 输入<code>open</code>打开文件夹或者文件夹</li><li><strong>Revealing Files:</strong> 输入<code>find</code>查询文件或者文件夹的位置</li><li><strong>Inside Files:</strong> 输入<code>in</code>查找文本文件内含的文字</li><li><strong>File Tags:</strong> 输入<code>tags</code>查询含有查询tags的文件或文件夹</li><li><strong>Don’t Show:</strong> 顾名思义</li><li><strong>Result Limit:</strong> 顾名思义</li></ul><h6 id="导航（Navigation）选项"><a href="#导航（Navigation）选项" class="headerlink" title="导航（Navigation）选项"></a>导航（Navigation）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190605234856681.png" alt="image-20190605234856681" title>                </div>                <div class="image-caption">image-20190605234856681</div>            </figure><ul><li><strong>Filtering:</strong> 模糊查询，例如 gc 匹配 Google Chrome</li><li><strong>Shortcuts:</strong> 可以使用左右箭头为文件夹导航的快捷键，使用回车键为打开选中文件夹的快捷键（注意：默认情况下右键为显示动作面板，Command + 下键为前往下一层文件夹，Command + 上键为前往上一层文件夹，回车键为进入选中的文件夹，建议不要改动）</li><li><strong>Previous Path:</strong> 直接进入上一次的路径</li></ul><h6 id="缓存（Buffer）选项"><a href="#缓存（Buffer）选项" class="headerlink" title="缓存（Buffer）选项"></a>缓存（Buffer）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190605235931668.png" alt="image-20190605235931668" title>                </div>                <div class="image-caption">image-20190605235931668</div>            </figure><p>可以将查找到的文件或者文件夹加入到缓存中，然后对这些文件作批量处理例如压缩、邮件等等</p><ul><li>通过<code>Option + 上键</code>来将选中的文件或者文件夹加入都缓存中</li><li>通过<code>Option + 右键</code>来批量处理缓存中的文件夹或者文件，例如移动、删除、发邮件、拷贝等等</li><li>通过<code>Option + 下键</code>可以添加一个文件到缓存中并移动到下一选择项</li><li>通过<code>Option + 左键</code>可以移除已添加在缓存区中的最后一项</li><li><strong>Buffer Clearing:</strong> 默认处理这些文件或文件夹后清除缓存区，但是同时也提供了超过5分钟不使用即清楚缓存区的选项（建议选择）。也可以手动清除缓存区，用<code>Option + 空格</code>清除所有，或者按住<code>Option</code>鼠标点击以删除某一个。其中最后一个选项可以使用<code>Shift + Option</code>作为<code>Option</code>键的替代（建议不要选择）</li></ul><h6 id="高级（Advanced）选项"><a href="#高级（Advanced）选项" class="headerlink" title="高级（Advanced）选项"></a>高级（Advanced）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190606001742205.png" alt="image-20190606001742205" title>                </div>                <div class="image-caption">image-20190606001742205</div>            </figure><ul><li><strong>Copy Path:</strong> 使用了将目录拷贝至粘贴板的功能后会在目录前后加上单引号</li><li><strong>AppleScripts:</strong> 默认直接执行脚本，使用<code>Command + o</code>来打开AppleScripts编辑器</li><li><strong>Performance:</strong> 避免使用文件自己的图标（有啥用我也没搞懂）</li><li><strong>Sorting:</strong> 没看懂是干啥的</li><li><strong>Home Folder:</strong> 设置表示home文件夹字符，默认<code>~</code></li></ul><h5 id="动作（Actions）选项"><a href="#动作（Actions）选项" class="headerlink" title="动作（Actions）选项"></a>动作（Actions）选项</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607145930674.png" alt="image-20190607145930674" title>                </div>                <div class="image-caption">image-20190607145930674</div>            </figure><p>如上面所说，这个主要是用来设置快捷键来显示操作界面</p><p><strong>Show Actions:</strong> 设置调出动作的快捷键</p><p><strong>Selection Hotkey:</strong> 上面那个快捷键是对选中的文件或文件夹调出操作界面，而这个快捷键是对当前目录调出操作界面</p><p><strong>Action Ordering:</strong> Alfred会根据对动作的使用频次来排列动作列表</p><p><strong>File Actions:</strong> 选择在操作界面可以选择的动作</p><h5 id="网页搜索（Web-Search）"><a href="#网页搜索（Web-Search）" class="headerlink" title="网页搜索（Web Search）"></a>网页搜索（Web Search）</h5><p>网页搜索的一些设置，可以使用默认的也可以自定义搜索功能</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607151144943.png" alt="image-20190607151144943" title>                </div>                <div class="image-caption">image-20190607151144943</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607151250829.png" alt="image-20190607151250829" title>                </div>                <div class="image-caption">image-20190607151250829</div>            </figure><p>在设置自定义查询界面：</p><p><strong>Search URL:</strong> 网站查询的URL，其中查询内容用{query}代替</p><p><strong>Title:</strong> 标题</p><p><strong>Keyword:</strong> 查询关键字</p><p><strong>Validation:</strong> 用来测试有效性</p><p>每个查询还能设置相应的图标</p><h5 id="书签搜索（Web-Bookmarks）"><a href="#书签搜索（Web-Bookmarks）" class="headerlink" title="书签搜索（Web Bookmarks）"></a>书签搜索（Web Bookmarks）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607151558368.png" alt="image-20190607151558368" title>                </div>                <div class="image-caption">image-20190607151558368</div>            </figure><p><strong>Sources:</strong> 来源，有Safari 和 Chrome两个选项</p><p><strong>Show bookmarks:</strong> 是否需要一个特别的关键字</p><p><strong>Open Bookmarks:</strong> 选择游览器打开书签</p><h4 id="剪贴板历史（Clipboard）"><a href="#剪贴板历史（Clipboard）" class="headerlink" title="剪贴板历史（Clipboard）"></a>剪贴板历史（Clipboard）</h4><h6 id="历史（History）"><a href="#历史（History）" class="headerlink" title="历史（History）"></a>历史（History）</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607152214263.png" alt="image-20190607152214263" title>                </div>                <div class="image-caption">image-20190607152214263</div>            </figure><p><strong>Clipboard History:</strong> 剪贴板历史保留时间</p><p><strong>Viewer Hotkey:</strong> 浏览剪贴板历史的快捷键</p><p><strong>Viewer Keyword:</strong> 浏览剪贴板历史的关键字</p><p><strong>Clear Keyword:</strong> 清除历史</p><p><strong>Snippets:</strong> 分别是把片段展示在剪贴板历史界面的前面和在剪贴板历史界面中显示片段</p><p><strong>Universal:</strong> 众所周知，苹果设置之间可以通过剪贴板传递数据，这里可以忽略从其它设备来的数据</p><h6 id="合并（Merging）"><a href="#合并（Merging）" class="headerlink" title="合并（Merging）"></a>合并（Merging）</h6><h6 id><a href="#" class="headerlink" title></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607153044572.png" alt="image-20190607153044572" title>                </div>                <div class="image-caption">image-20190607153044572</div>            </figure></h6><p>开启前面的保存历史记录后，我们可以按住<code>command</code>键或者按两次<code>C</code>键把当前的剪贴板数据增加到前一次的剪贴板数据里面</p><p>同时第二个选择框选中后，可以将合并后的数据放入当前剪贴板而不用去选择上一次的</p><p>下拉框可以选择两段记录连接的方式比如用空格连接</p><p>最后一个选择框表示成功后播放声音</p><h6 id="高级（Advanced）"><a href="#高级（Advanced）" class="headerlink" title="高级（Advanced）"></a>高级（Advanced）</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607153634246.png" alt="image-20190607153634246" title>                </div>                <div class="image-caption">image-20190607153634246</div>            </figure><p><strong>Matching:</strong> 匹配时对音符和unicode不敏感</p><p><strong>Pasting:</strong> 自动粘贴选择的对象到当前活动的应用把用过的剪贴板历史移到最顶端</p><p><strong>Max Clip Size:</strong> 复制内容的最大字节数，超过会被忽略</p><p><strong>Ignore Apps:</strong> 忽略的应用，一般包括存储密码的应用</p><h5 id="片段（Snippets）"><a href="#片段（Snippets）" class="headerlink" title="片段（Snippets）"></a>片段（Snippets）</h5><p>此功能主要是用来设置文本片段，便于快速输入。例如，实现快速输入地址、常用问候语、常用代码片段（例如html可以设置为整个html模板）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607155253751.png" alt="image-20190607155253751" title>                </div>                <div class="image-caption">image-20190607155253751</div>            </figure><p><strong>Viewer Hotkey:</strong> 查看片段的快捷键</p><p><strong>Snippet Keyword:</strong> 关键字</p><p><strong>Matching:</strong> 匹配的内容例如名字和关键字</p><p>左边可以添加一些片段合集，右边可以添加自定义的片段</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607155903819.png" alt="image-20190607155903819" title>                </div>                <div class="image-caption">image-20190607155903819</div>            </figure><p>其中片段中还可以加入类似{time}{data}{clipboard}这种格式的动态文本</p><h5 id="计算器（Calculator）"><a href="#计算器（Calculator）" class="headerlink" title="计算器（Calculator）"></a>计算器（Calculator）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607160012526.png" alt="image-20190607160012526" title>                </div>                <div class="image-caption">image-20190607160012526</div>            </figure><p><strong>Standard:</strong> 能够直接输入类似15*3这种表达式来进行简单的计算</p><p><strong>Advanced:</strong> 通过以’=’开头来进行一些高级的计算</p><p><strong>Input &amp; Output:</strong> 输入输出格式</p><h5 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607160608618.png" alt="image-20190607160608618" title>                </div>                <div class="image-caption">image-20190607160608618</div>            </figure><p><strong>Language:</strong> 语言</p><p><strong>Define a word:</strong> 在这个关键字后接单词，并用回车在字典应用中打开</p><p><strong>Spell a word:</strong> 在这个关键字后接单词，并用回车把这个单词放进剪贴板</p><h5 id="联系人（Contacts）"><a href="#联系人（Contacts）" class="headerlink" title="联系人（Contacts）"></a>联系人（Contacts）</h5><h6 id="Contacts选项"><a href="#Contacts选项" class="headerlink" title="Contacts选项"></a>Contacts选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607161649876.png" alt="image-20190607161649876" title>                </div>                <div class="image-caption">image-20190607161649876</div>            </figure><p>这里我们可以设置查询到联系人后使用哪些操作，例如点击名字拷贝到剪贴板和点击右键地址直接发送邮件，另外还支持URL Scheme来打开任意App</p><h6 id="Email选项"><a href="#Email选项" class="headerlink" title="Email选项"></a>Email选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607161806237.png" alt="image-20190607161806237" title>                </div>                <div class="image-caption">image-20190607161806237</div>            </figure><p>这里可以设置发邮件的关键字，也可以设置打开Gmail网页来代替系统的邮件app来发送邮件。另外还可以设置如果有单个附件或多个附件的情况下邮件主题栏显示的文字</p><h6 id="高级（Advanced）-1"><a href="#高级（Advanced）-1" class="headerlink" title="高级（Advanced）"></a>高级（Advanced）</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607162037775.png" alt="image-20190607162037775" title>                </div>                <div class="image-caption">image-20190607162037775</div>            </figure><p>这里可以设置联系人搜索结果的展示，比如姓名展示顺序、显示职位、显示工作等</p><h5 id="iTunes"><a href="#iTunes" class="headerlink" title="iTunes"></a>iTunes</h5><h6 id="通用（General）选项"><a href="#通用（General）选项" class="headerlink" title="通用（General）选项"></a>通用（General）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607162241309.png" alt="image-20190607162241309" title>                </div>                <div class="image-caption">image-20190607162241309</div>            </figure><p>这个功能类似一个iTunes的mini播放器</p><p><strong>Mini Player:</strong> 用来设置打开mini播放器的热键和关键字</p><p><strong>Playback:</strong> 如果使用随机选择专辑命令，只会选择歌曲数大于5的专辑</p><p><strong>Behaviour:</strong> 查询并选中歌曲后自动关闭mini播放器界面</p><p><strong>Searching:</strong> 查询歌曲后自动会在iTunes内添加播放列表</p><h6 id="关键字（Keywords）选项"><a href="#关键字（Keywords）选项" class="headerlink" title="关键字（Keywords）选项"></a>关键字（Keywords）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607162716103.png" alt="image-20190607162716103" title>                </div>                <div class="image-caption">image-20190607162716103</div>            </figure><p>设置iTunes播放命令的关键字</p><p><strong>Play/Pause:</strong> 播放暂停</p><p><strong>Next Track:</strong> 下一曲</p><p><strong>Back Track:</strong> ？？？</p><p><strong>Previous Track:</strong> 上一曲</p><p><strong>Random Track:</strong> 随机选择专辑</p><p><strong>Max Volume:</strong> 最大音量</p><p><strong>Mute iTunes:</strong> 静音</p><p>选中了 Show these keywords in Alfred Default Results 后还可以在搜索界面使用这些命令</p><h6 id="高级（Advanced）选项-1"><a href="#高级（Advanced）选项-1" class="headerlink" title="高级（Advanced）选项"></a>高级（Advanced）选项</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607163129340.png" alt="image-20190607163129340" title>                </div>                <div class="image-caption">image-20190607163129340</div>            </figure><p>主要设置iTunes的资料库目录</p><h5 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h5><p>可以直接在Alfred内直接搜索密码库，但是需要在1Password内设置第三方app支持</p><h5 id="系统（System）"><a href="#系统（System）" class="headerlink" title="系统（System）"></a>系统（System）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607163631051.png" alt="image-20190607163631051" title>                </div>                <div class="image-caption">image-20190607163631051</div>            </figure><p><strong>常规系统命令：</strong> 屏幕保护程序<code>screen saver</code>、显示回收站<code>trash</code>、清空回收站<code>empty trash</code>、登出<code>logout</code>、睡眠<code>sleep</code>、锁定<code>lock</code>、重启<code>restart</code>、关机<code>shutdown</code></p><p><strong>程序管理命令：</strong> 隐藏<code>hide</code>、关闭<code>quit</code>、强制关闭<code>forcequit</code>、关闭所有应用程序<code>quitall</code></p><p><strong>盘符管理命令：</strong> 推出某个盘符<code>eject</code>、推出所有盘符<code>ejectall</code>、设置盘符黑名单</p><p><strong>音量管理：</strong> 音量升高<code>volup</code>、音量降低<code>voldown</code>、静音<code>mute</code></p><h5 id="终端（Terminal）"><a href="#终端（Terminal）" class="headerlink" title="终端（Terminal）"></a>终端（Terminal）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607164201362.png" alt="image-20190607164201362" title>                </div>                <div class="image-caption">image-20190607164201362</div>            </figure><p>输入<code>&gt;</code>进入控制台命令</p><h5 id="Large-Type"><a href="#Large-Type" class="headerlink" title="Large Type"></a>Large Type</h5><p>设置展示和字体</p><h5 id="预览（Previews）"><a href="#预览（Previews）" class="headerlink" title="预览（Previews）"></a>预览（Previews）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607164419374.png" alt="image-20190607164419374" title>                </div>                <div class="image-caption">image-20190607164419374</div>            </figure><p><strong>Quick Look:</strong> 使用<code>shift</code>键预览所选中的文件</p><p><strong>Previews:</strong> 展示富文本</p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="网页搜索自定义"><a href="#网页搜索自定义" class="headerlink" title="网页搜索自定义"></a>网页搜索自定义</h4><p>因为众所周知的原因，Alfred默认设置的搜索网站几乎无法使用，所以需要自定义网页搜索</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/image-20190607165835771.png" alt="image-20190607165835771" title>                </div>                <div class="image-caption">image-20190607165835771</div>            </figure><p>例如上图是对百度搜索的设置</p><blockquote><ul><li>百度：<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}" rel="external nofollow noopener noreferrer" target="_blank">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>淘宝：<a href="http://s.taobao.com/search?oe=utf-8&amp;f=8&amp;q={query}" rel="external nofollow noopener noreferrer" target="_blank">http://s.taobao.com/search?oe=utf-8&amp;f=8&amp;q={query}</a></li><li>Github：<a href="https://github.com/search?utf8=%E2%9C%93&amp;q={query}" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>知乎：<a href="http://www.zhihu.com/search?q={query}" rel="external nofollow noopener noreferrer" target="_blank">http://www.zhihu.com/search?q={query}</a></li></ul></blockquote><h4 id="快速在当前Finder窗口创建新文件"><a href="#快速在当前Finder窗口创建新文件" class="headerlink" title="快速在当前Finder窗口创建新文件"></a>快速在当前Finder窗口创建新文件</h4><p>Alfred中输入关键词「nf + 空格 + 文件名.后缀」，即可在当前Finder窗口下新建一个文件。「nfo + 空格 + 文件名.后缀」新建并打开，多个文件用「/」分隔</p><p>如果没有打开的Finder窗口，则默认在桌面新建</p><p><a href="http://www.packal.org/workflow/newfile" rel="external nofollow noopener noreferrer" target="_blank">下载链接</a></p><h4 id="快速切换终端路径"><a href="#快速切换终端路径" class="headerlink" title="快速切换终端路径"></a>快速切换终端路径</h4><ul><li><code>ft</code>: open current <strong>Finder</strong> directory in <strong>Terminal</strong></li><li><code>tf</code>: open current <strong>Terminal</strong> directory in <strong>Finder</strong></li><li><code>fi</code>: open current <strong>Finder</strong> directory in <strong>iTerm</strong></li><li><code>if</code>: open current <strong>iTerm</strong> directory in <strong>Finder</strong></li><li><code>pt</code>: open current <strong>Path Finder</strong> directory in <strong>Terminal</strong></li><li><code>tp</code>: open current <strong>Terminal</strong> directory in <strong>Path Finder</strong></li><li><code>pi</code>: open current <strong>Path Finder</strong> directory in <strong>iTerm</strong></li><li><code>ip</code>: open current <strong>iTerm</strong> directory in <strong>Path Finder</strong></li></ul><p><a href="http://www.packal.org/workflow/terminalfinder" rel="external nofollow noopener noreferrer" target="_blank">下载链接</a></p><h4 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h4><ol><li>中英文互翻</li><li>按住<code>cmd + 回车</code>即可发音</li><li>输入<code>yd *</code>可以查询最近的查询记录</li><li>在选项上回车可以复制翻译结果</li><li>翻译结果上按住<code>shift</code>可以直接浏览有道网页</li><li>双击<code>option</code>键可以翻译选中内容</li></ol><p><a href="https://github.com/wensonsmith/YoudaoTranslate" rel="external nofollow noopener noreferrer" target="_blank">下载链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多次看到别人在Mac上使用Alfred，终于被酷炫的操作所折服，开始鼓捣这个庞大且&lt;del&gt;复杂&lt;/del&gt;（并不）的效率神器。下面记录一下整个学习使用的过程。&lt;/p&gt;
&lt;p&gt;本文使用的是Alfred 4.0.1，付费正版（肉痛）。&lt;/p&gt;
&lt;h3 id=&quot;软件介绍&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="效率工具" scheme="https://zhaoziwen.com.cn/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="alfred" scheme="https://zhaoziwen.com.cn/tags/alfred/"/>
    
      <category term="效率工具" scheme="https://zhaoziwen.com.cn/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>二叉查找树</title>
    <link href="https://zhaoziwen.com.cn/archives/1052ab9e.html"/>
    <id>https://zhaoziwen.com.cn/archives/1052ab9e.html</id>
    <published>2019-06-06T07:10:21.000Z</published>
    <updated>2019-06-06T07:16:10.216Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要给出二叉查找树的Java实现，并对其中一些重要点和函数进行记录</p><h4 id="二叉查找树节点的定义"><a href="#二叉查找树节点的定义" class="headerlink" title="二叉查找树节点的定义"></a>二叉查找树节点的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BSTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode&lt;T&gt; left;      <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; right;     <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTNode</span><span class="params">(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> search(x.right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> search(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">            x = x.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iterativeSearch(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像是尽量使用非递归版本？递归版本会因为函数栈占用很多无用内存</p><h4 id="前驱和后继"><a href="#前驱和后继" class="headerlink" title="前驱和后继"></a>前驱和后继</h4><p>前驱节点：二叉树中序遍历后和这个节点相邻的前面的节点</p><p>后继节点：二叉树中序遍历后和这个节点相邻的后面的节点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190606130547.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>中序遍历顺序：8-&gt;4-&gt;9-&gt;2-&gt;10-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7</p><p>4号节点的前驱节点为8号节点，后继节点为9号节点</p><h5 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h5><ol><li><p>如果当前节点的左子树不为空，那么该点的前驱节点为该点左子树最右的节点（最大的节点）</p></li><li><p>如果当前节点的左子树为空，那么该点的前驱节点为从该点往上延伸，如果延伸到的点为其父亲节点的右孩子，那么这个父亲节点就是该点的前驱节点</p><p>例如上图中的10号节点，10号节点的左子树为空，且10号节点不是其父亲节点的右孩子，则继续往上延伸，5号节点是其父亲节点的右孩子，所以，2号节点就是10号节点的前驱节点</p><p>8号节点没有前驱节点</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱节点。即，查找"二叉树中数据值小于该节点"的"最大节点"。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则"x的前驱节点"为 "以其左孩子为根的子树的最大节点"。</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> maximum(x.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父节点"。</span></span><br><span class="line">    <span class="comment">// (02) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父节点"就是"x的前驱节点"。</span></span><br><span class="line">    BSTNode&lt;T&gt; y = x.parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="keyword">null</span>) &amp;&amp; (x==y.left)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h5><ol><li>如果当前节点的右子树不为空，那么该点的后继节点为该点右子树最左的节点（最小的节点）</li><li>如果当前节点的右子树为空，那么该点的后继节点为从该点往上延伸，如果延伸到的点为其父亲节点的左孩子，那么这个父亲节点就是该点的后继节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继节点。即，查找"二叉树中数据值大于该节点"的"最小节点"。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则"x的后继节点"为 "以其右孩子为根的子树的最小节点"。</span></span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> minimum(x.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是"一个左孩子"，则"x的后继节点"为 "它的父节点"。</span></span><br><span class="line">    <span class="comment">// (02) x是"一个右孩子"，则查找"x的最低的父节点，并且该父结点要具有左孩子"，找到的这个"最低的父节点"就是"x的后继节点"。</span></span><br><span class="line">    BSTNode&lt;T&gt; y = x.parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="keyword">null</span>) &amp;&amp; (x==y.right)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中（允许重复值）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     bst 二叉树</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTree&lt;T&gt; bst, BSTNode&lt;T&gt; z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    <span class="comment">// y为z应该插入位置的父节点</span></span><br><span class="line">    <span class="comment">// x为z应该插入的位置</span></span><br><span class="line">    BSTNode&lt;T&gt; y = <span class="keyword">null</span>;</span><br><span class="line">    BSTNode&lt;T&gt; x = bst.mRoot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x为z应该插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// y为应该插入的位置的父节点</span></span><br><span class="line">        y = x;</span><br><span class="line">        cmp = z.key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z.parent = y;</span><br><span class="line">    <span class="comment">// 二叉树是空树</span></span><br><span class="line">    <span class="keyword">if</span> (y == <span class="keyword">null</span>)</span><br><span class="line">        bst.mRoot = z;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cmp = z.key.compareTo(y.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            y.left = z;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y.right = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 新建结点(key)，并将其插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    BSTNode&lt;T&gt; z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> (z != <span class="keyword">null</span>)</span><br><span class="line">        insert(<span class="keyword">this</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除有3中情况：</p><ol><li>没有左右子节点，可以直接删除</li><li>存在左节点或者右节点，删除后需要对子节点移动</li><li>同时存在左右子节点，通过与后继节点交换后，删除后继节点</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190606144115.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图删除20号节点，只需要删除该节点和父节点的关系即可（情况1）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190606144128.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图删除70号节点，只需要断开两个关系，然后建立父节点和子节点的关系即可（情况2）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190606144253.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图删除30号节点，将该节点与它的后继节点交换，然后删除后继节点即可（情况3，交换后转为前两种情况）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/20190606144337.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第 3 种情况，如果同时存在左右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//获取后继结点</span></span><br><span class="line">        BSTNode&lt;T&gt; successor = successor(node);</span><br><span class="line">        <span class="comment">//转移后继结点值到当前节点</span></span><br><span class="line">        node.key = successor.key;</span><br><span class="line">        <span class="comment">//把要删除的当前节点设置为后继结点</span></span><br><span class="line">        node = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过前一步处理，下面只有前两种情况，只能是一个节点或者没有节点</span></span><br><span class="line">    <span class="comment">//不管是否有子节点，都获取子节点</span></span><br><span class="line">    BSTNode&lt;T&gt; child;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">        child = node.left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        child = node.right;</span><br><span class="line">    <span class="comment">//如果 child != null，就说明是有一个节点的情况    </span></span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//将子节点和父节点关联上</span></span><br><span class="line">        child.parent = node.parent;</span><br><span class="line">    <span class="comment">//如果当前节点没有父节点（后继情况到这儿时一定有父节点）</span></span><br><span class="line">    <span class="comment">//说明要删除的就是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//根节点设置为子节点</span></span><br><span class="line">        <span class="comment">//按照前面逻辑，根只有一个或者没有节点，所以直接赋值 child 即可</span></span><br><span class="line">        mRoot = child;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left)<span class="comment">//存在父节点，并且当前节点是左节点时</span></span><br><span class="line">        <span class="comment">//将父节点的左节点设置为 child</span></span><br><span class="line">        node.parent.left = child;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//右节点时</span></span><br><span class="line">        <span class="comment">//将父节点的右节点设置为 child</span></span><br><span class="line">        node.parent.right = child;</span><br><span class="line">    <span class="comment">//返回被删除的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除指定的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取要删除的节点</span></span><br><span class="line">    BSTNode&lt;T&gt; node = search(mRoot, key);</span><br><span class="line">    <span class="comment">//如果存在就删除</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">       remove(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉查找树的Java实现（BSTree-java）"><a href="#二叉查找树的Java实现（BSTree-java）" class="headerlink" title="二叉查找树的Java实现（BSTree.java）"></a>二叉查找树的Java实现（BSTree.java）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BSTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode&lt;T&gt; left;    <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; right;    <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BSTNode</span><span class="params">(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"key:"</span>+key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRoot=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 前序遍历"二叉树"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(tree.key+<span class="string">" "</span>);</span><br><span class="line">            preOrder(tree.left);</span><br><span class="line">            preOrder(tree.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preOrder(mRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中序遍历"二叉树"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(tree.left);</span><br><span class="line">            System.out.print(tree.key+<span class="string">" "</span>);</span><br><span class="line">            inOrder(tree.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inOrder(mRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 后序遍历"二叉树"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            postOrder(tree.left);</span><br><span class="line">            postOrder(tree.right);</span><br><span class="line">            System.out.print(tree.key+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postOrder(mRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> search(x.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> search(x.right, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">search</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(mRoot, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (非递归实现)查找"二叉树x"中键值为key的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt; x, T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">                x = x.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">                x = x.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterativeSearch(mRoot, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tree.left != <span class="keyword">null</span>)</span><br><span class="line">            tree = tree.left;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BSTNode&lt;T&gt; p = minimum(mRoot);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> p.key;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tree.right != <span class="keyword">null</span>)</span><br><span class="line">            tree = tree.right;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BSTNode&lt;T&gt; p = maximum(mRoot);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> p.key;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 找结点(x)的后继结点。即，查找"二叉树中数据值大于该结点"的"最小结点"。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span></span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> minimum(x.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">// (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</span></span><br><span class="line">        <span class="comment">// (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。</span></span><br><span class="line">        BSTNode&lt;T&gt; y = x.parent;</span><br><span class="line">        <span class="keyword">while</span> ((y!=<span class="keyword">null</span>) &amp;&amp; (x==y.right)) &#123;</span><br><span class="line">            x = y;</span><br><span class="line">            y = y.parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 找结点(x)的前驱结点。即，查找"二叉树中数据值小于该结点"的"最大结点"。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BSTNode&lt;T&gt; <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> maximum(x.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span></span><br><span class="line">        <span class="comment">// (01) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。</span></span><br><span class="line">        BSTNode&lt;T&gt; y = x.parent;</span><br><span class="line">        <span class="keyword">while</span> ((y!=<span class="keyword">null</span>) &amp;&amp; (x==y.left)) &#123;</span><br><span class="line">            x = y;</span><br><span class="line">            y = y.parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *     tree 二叉树的</span></span><br><span class="line"><span class="comment">     *     z 插入的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTree&lt;T&gt; bst, BSTNode&lt;T&gt; z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        BSTNode&lt;T&gt; y = <span class="keyword">null</span>;</span><br><span class="line">        BSTNode&lt;T&gt; x = bst.mRoot;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找z的插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            cmp = z.key.compareTo(x.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                x = x.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = x.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        z.parent = y;</span><br><span class="line">        <span class="keyword">if</span> (y==<span class="keyword">null</span>)</span><br><span class="line">            bst.mRoot = z;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cmp = z.key.compareTo(y.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                y.left = z;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y.right = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 新建结点(key)，并将其插入到二叉树中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment">     *     key 插入结点的键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        BSTNode&lt;T&gt; z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">        <span class="keyword">if</span> (z != <span class="keyword">null</span>)</span><br><span class="line">            insert(<span class="keyword">this</span>, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     *     bst 二叉树</span></span><br><span class="line"><span class="comment">     *     z 删除的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BSTNode&lt;T&gt; <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//第 3 种情况，如果同时存在左右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//获取后继结点</span></span><br><span class="line">            BSTNode&lt;T&gt; successor = successor(node);</span><br><span class="line">            <span class="comment">//转移后继结点值到当前节点</span></span><br><span class="line">            node.key = successor.key;</span><br><span class="line">            <span class="comment">//把要删除的当前节点设置为后继结点</span></span><br><span class="line">            node = successor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过前一步处理，下面只有前两种情况，只能是一个节点或者没有节点</span></span><br><span class="line">        <span class="comment">//不管是否有子节点，都获取子节点</span></span><br><span class="line">        BSTNode&lt;T&gt; child;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            child = node.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            child = node.right;</span><br><span class="line">        <span class="comment">//如果 child != null，就说明是有一个节点的情况    </span></span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将子节点和父节点关联上</span></span><br><span class="line">            child.parent = node.parent;</span><br><span class="line">        <span class="comment">//如果当前节点没有父节点（后继情况到这儿时一定有父节点）</span></span><br><span class="line">        <span class="comment">//说明要删除的就是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//根节点设置为子节点</span></span><br><span class="line">            <span class="comment">//按照前面逻辑，根只有一个或者没有节点，所以直接赋值 child 即可</span></span><br><span class="line">            mRoot = child;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left)<span class="comment">//存在父节点，并且当前节点是左节点时</span></span><br><span class="line">            <span class="comment">//将父节点的左节点设置为 child</span></span><br><span class="line">            node.parent.left = child;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右节点时</span></span><br><span class="line">            <span class="comment">//将父节点的右节点设置为 child</span></span><br><span class="line">            node.parent.right = child;</span><br><span class="line">        <span class="comment">//返回被删除的节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取要删除的节点</span></span><br><span class="line">        BSTNode&lt;T&gt; node = search(mRoot, key);</span><br><span class="line">        <span class="comment">//如果存在就删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">           remove(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 销毁二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tree.left != <span class="keyword">null</span>)</span><br><span class="line">            destroy(tree.left);</span><br><span class="line">        <span class="keyword">if</span> (tree.right != <span class="keyword">null</span>)</span><br><span class="line">            destroy(tree.right);</span><br><span class="line"></span><br><span class="line">        tree=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        destroy(mRoot);</span><br><span class="line">        mRoot = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 打印"二叉查找树"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key        -- 节点的键值 </span></span><br><span class="line"><span class="comment">     * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment">     *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment">     *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt; tree, T key, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">                System.out.printf(<span class="string">"%2d is root\n"</span>, tree.key);</span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">                System.out.printf(<span class="string">"%2d is %2d's %6s child\n"</span>, tree.key, key, direction==<span class="number">1</span>?<span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line"></span><br><span class="line">            print(tree.left, tree.key, -<span class="number">1</span>);</span><br><span class="line">            print(tree.right,tree.key,  <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRoot != <span class="keyword">null</span>)</span><br><span class="line">            print(mRoot, mRoot.key, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试程序（BSTreeTest-java）"><a href="#测试程序（BSTreeTest-java）" class="headerlink" title="测试程序（BSTreeTest.java）"></a>测试程序（BSTreeTest.java）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, ilen;</span><br><span class="line">        BSTree&lt;Integer&gt; tree=<span class="keyword">new</span> BSTree&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"== 依次添加: "</span>);</span><br><span class="line">        ilen = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">            tree.insert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\n== 前序遍历: "</span>);</span><br><span class="line">        tree.preOrder();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\n== 中序遍历: "</span>);</span><br><span class="line">        tree.inOrder();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\n== 后序遍历: "</span>);</span><br><span class="line">        tree.postOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"== 最小值: "</span>+ tree.minimum());</span><br><span class="line">        System.out.println(<span class="string">"== 最大值: "</span>+ tree.maximum());</span><br><span class="line">        System.out.println(<span class="string">"== 树的详细信息: "</span>);</span><br><span class="line">        tree.print();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\n== 删除根节点: "</span>+ arr[<span class="number">3</span>]);</span><br><span class="line">        tree.remove(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\n== 中序遍历: "</span>);</span><br><span class="line">        tree.inOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        tree.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">== 依次添加: 1 5 4 3 2 6 </span><br><span class="line">== 前序遍历: 1 5 4 3 2 6 </span><br><span class="line">== 中序遍历: 1 2 3 4 5 6 </span><br><span class="line">== 后序遍历: 2 3 4 6 5 1 </span><br><span class="line">== 最小值: 1</span><br><span class="line">== 最大值: 6</span><br><span class="line">== 树的详细信息: </span><br><span class="line">is root</span><br><span class="line">is  1&apos;s  right child</span><br><span class="line">is  5&apos;s   left child</span><br><span class="line">is  4&apos;s   left child</span><br><span class="line">is  3&apos;s   left child</span><br><span class="line">is  5&apos;s  right child</span><br><span class="line"></span><br><span class="line">== 删除根节点: 3</span><br><span class="line">== 中序遍历: 1 2 4 5 6</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在树结构中并没有分的很清楚节点和结点的区别，而且也没有搜索出这两者的区别，所以在本文中会存在混用的问题，不过都表示的是一个东西…</p><h4 id="参考及来源"><a href="#参考及来源" class="headerlink" title="参考及来源"></a>参考及来源</h4><ol><li><a href="http://www.cnblogs.com/skywang12345/p/3576452.html" rel="external nofollow noopener noreferrer" target="_blank">二叉查找树(三)之 Java的实现</a></li><li><a href="https://blog.csdn.net/isea533/article/details/80345507" rel="external nofollow noopener noreferrer" target="_blank">二叉查找树 - 删除节点 详解(Java实现)</a></li><li><a href="https://blog.csdn.net/qq_40938077/article/details/80463299" rel="external nofollow noopener noreferrer" target="_blank">左神课堂之寻找二叉树的前驱节点和后继节点</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要给出二叉查找树的Java实现，并对其中一些重要点和函数进行记录&lt;/p&gt;
&lt;h4 id=&quot;二叉查找树节点的定义&quot;&gt;&lt;a href=&quot;#二叉查找树节点的定义&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树节点的定义&quot;&gt;&lt;/a&gt;二叉查找树节点的定义&lt;/h
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树结构" scheme="https://zhaoziwen.com.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>http重定向至https</title>
    <link href="https://zhaoziwen.com.cn/archives/b2526d14.html"/>
    <id>https://zhaoziwen.com.cn/archives/b2526d14.html</id>
    <published>2019-06-04T03:39:00.000Z</published>
    <updated>2019-06-05T07:59:29.949Z</updated>
    
    <content type="html"><![CDATA[<p>利用重定向将http请求全部转为https请求</p><p>其中nginx中的设置为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name     zhaoziwen.com.cn www.zhaoziwen.com.cn blog.zhaoziwen.com.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root        /root/zhaowenzi.github.io;</span><br><span class="line">        index       index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/blog.zhaoziwen.com.cn/fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/blog.zhaoziwen.com.cn/privkey.pem; # managed by Certbot</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    if ($host = blog.zhaoziwen.com.cn) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line">    if ($host = zhaoziwen.com.cn) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($host = www.zhaoziwen.com.cn) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     blog.zhaoziwen.com.cn www.zhaoziwen.com.cn zhaoziwen.com.cn;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用重定向将http请求全部转为https请求&lt;/p&gt;
&lt;p&gt;其中nginx中的设置为&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="环境配置" scheme="https://zhaoziwen.com.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="nginx" scheme="https://zhaoziwen.com.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="https://zhaoziwen.com.cn/archives/afcbc60d.html"/>
    <id>https://zhaoziwen.com.cn/archives/afcbc60d.html</id>
    <published>2019-06-03T03:51:44.000Z</published>
    <updated>2019-06-05T07:59:29.951Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="安装NodeJS和NPM"><a href="#安装NodeJS和NPM" class="headerlink" title="安装NodeJS和NPM"></a>安装NodeJS和NPM</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash -</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure></li><li><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>将以下内容拷贝进去</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><p>由于centos默认自带防火墙，所以这里需要关闭防火墙才能访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service#启动firewall</span><br><span class="line">systemctl stop firewalld.service#停止firewall</span><br><span class="line">systemctl disable firewalld.service#禁止firewall开机启动</span><br></pre></td></tr></table></figure></li><li><h4 id="安装git并设置"><a href="#安装git并设置" class="headerlink" title="安装git并设置"></a>安装git并设置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install git#安装git</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C "xxxxx@xxx.com"  #生成公钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub#查看公钥，并把它复制到github账户中</span><br></pre></td></tr></table></figure></li><li><h4 id="拉取仓库并配置nginx"><a href="#拉取仓库并配置nginx" class="headerlink" title="拉取仓库并配置nginx"></a>拉取仓库并配置nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone ...</span><br><span class="line"></span><br><span class="line">vim /etc/nginx/conf.d/hexo.conf</span><br></pre></td></tr></table></figure><p>写入下列相应配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     blog.zhaoziwen.com.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root        /root/zhaowenzi.github.io;</span><br><span class="line">        index       index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>修改nginx权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将user nginx; 改为 user root; </span></span><br><span class="line"><span class="meta">#</span><span class="bash">然后再次重启</span></span><br></pre></td></tr></table></figure></li><li><h4 id="配置webhooks自动更新博客"><a href="#配置webhooks自动更新博客" class="headerlink" title="配置webhooks自动更新博客"></a>配置webhooks自动更新博客</h4><p>安装依赖库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g github-webhook-handler</span><br></pre></td></tr></table></figure><p>配置webhook.js</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim webhooks.js</span><br></pre></td></tr></table></figure><p>将下面的配置写入上面的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> createHandler = <span class="built_in">require</span>(<span class="string">'github-webhook-handler'</span>)</span><br><span class="line"><span class="keyword">var</span> handler = createHandler(&#123; <span class="attr">path</span>: <span class="string">'/webhooks_push'</span>, <span class="attr">secret</span>: <span class="string">'***'</span> &#125;)</span><br><span class="line"><span class="comment">// 上面的 secret 保持和 GitHub 后台设置的一致</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run_cmd</span>(<span class="params">cmd, args, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line">  <span class="keyword">var</span> child = spawn(cmd, args);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  child.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>) </span>&#123; resp += buffer.toString(); &#125;);</span><br><span class="line">  child.stdout.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; callback (resp) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  handler(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span></span><br><span class="line">    res.end(<span class="string">'no such location'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(<span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line">handler.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">handler.on(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received a push event for %s to %s'</span>,</span><br><span class="line">    event.payload.repository.name,</span><br><span class="line">    event.payload.ref);</span><br><span class="line">    run_cmd(<span class="string">'sh'</span>, [<span class="string">'./deploy.sh'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123; <span class="built_in">console</span>.log(text) &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>配置./deploy.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim deploy.sh</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/zhaowenzi.github.io</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>用pm2来实现守护进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 --global</span><br></pre></td></tr></table></figure><p>通过pm2启动webhooks.js</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start webhooks.js</span><br></pre></td></tr></table></figure></li><li><h4 id="全站HTTPS"><a href="#全站HTTPS" class="headerlink" title="全站HTTPS"></a>全站HTTPS</h4><p>通过Certbot傻瓜操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br><span class="line">sudo ./certbot-auto --nginx</span><br></pre></td></tr></table></figure><p>通过crontab定时任务自动更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>添加下面这条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * 0 /root/certbot-auto renew</span><br></pre></td></tr></table></figure><p>即每周日的0点0分执行更新证书的命令</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;安装NodeJS和NPM&quot;&gt;&lt;a href=&quot;#安装NodeJS和NPM&quot; class=&quot;headerlink&quot; title=&quot;安装NodeJS和NPM&quot;&gt;&lt;/a&gt;安装NodeJS和NPM&lt;/h4&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="博客" scheme="https://zhaoziwen.com.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://zhaoziwen.com.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhaoziwen.com.cn/archives/4a17b156.html"/>
    <id>https://zhaoziwen.com.cn/archives/4a17b156.html</id>
    <published>2019-06-02T16:01:41.400Z</published>
    <updated>2019-06-05T07:59:29.944Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" rel="external nofollow noopener noreferrer" target="_blank">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" rel="external nofollow noopener noreferrer" target="_blank">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" rel="external nofollow noopener noreferrer" target="_blank">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" rel="external nofollow noopener noreferrer" target="_blank">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" rel="external nofollow noopener noreferrer" target="_blank">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" rel="external nofollow noopener noreferrer" target="_blank">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt;! This is your very first post.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆及相关操作</title>
    <link href="https://zhaoziwen.com.cn/archives/4fa21f4d.html"/>
    <id>https://zhaoziwen.com.cn/archives/4fa21f4d.html</id>
    <published>2019-05-26T14:23:57.000Z</published>
    <updated>2019-06-05T07:59:29.944Z</updated>
    
    <content type="html"><![CDATA[<p>列举一些堆及相关操作的代码</p><p>相关数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> Weight = <span class="number">0</span>;</span><br><span class="line">  TreeNode *Left = <span class="literal">nullptr</span>;</span><br><span class="line">  TreeNode *Right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span> &#123;</span></span><br><span class="line">  TreeNode Data[MaxNum];</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个小根堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HeapNode *<span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  HeapNode *H = <span class="keyword">new</span>(HeapNode);</span><br><span class="line">  H-&gt;Data[<span class="number">0</span>].Weight = <span class="number">-1</span>;  <span class="comment">//第一个作为哨兵，从1开始计数</span></span><br><span class="line">  <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从堆中删除一个结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">DeleteMin</span><span class="params">(HeapNode *H)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Parent = <span class="number">0</span>, Child = <span class="number">0</span>;</span><br><span class="line">  TreeNode temp;</span><br><span class="line">  TreeNode *MinItem = <span class="keyword">new</span>(TreeNode);</span><br><span class="line">  *MinItem = H-&gt;Data[<span class="number">1</span>];</span><br><span class="line">  temp = (H-&gt;Data[(H-&gt;Size)--]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(Parent = <span class="number">1</span>; Parent * <span class="number">2</span> &lt;= H-&gt;Size; Parent = Child) &#123;</span><br><span class="line">    Child = Parent * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>((Child != H-&gt;Size) &amp;&amp; ((H-&gt;Data[Child].Weight) &gt; (H-&gt;Data[Child+<span class="number">1</span>].Weight))) &#123; <span class="comment">//找到最小的子结点</span></span><br><span class="line">      Child++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((temp.Weight) &lt;= (H-&gt;Data[Child].Weight)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      H-&gt;Data[Parent] = H-&gt;Data[Child]; <span class="comment">//把最小的值放到其父节点，执行Parent = Child并循环</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  H-&gt;Data[Parent] = temp;</span><br><span class="line">  <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在堆中插入一个结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(HeapNode *H, TreeNode *item)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  i = ++(H-&gt;Size);</span><br><span class="line">  <span class="keyword">for</span>(; H-&gt;Data[i/<span class="number">2</span>].Weight &gt; item-&gt;Weight; i/=<span class="number">2</span>) &#123;</span><br><span class="line">    H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  H-&gt;Data[i] = *item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将小根堆转化为哈夫曼树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">Huffman</span><span class="params">(HeapNode *H)</span> </span>&#123;</span><br><span class="line">  TreeNode *T = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">int</span> num = H-&gt;Size;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    T = <span class="keyword">new</span>(TreeNode);</span><br><span class="line">    T-&gt;Left = DeleteMin(H);</span><br><span class="line">    T-&gt;Right = DeleteMin(H);</span><br><span class="line">    T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">    Insert(H, T); <span class="comment">//注意：此时是把堆中最小的两个结点结合成一个结点，并重新插回小根堆</span></span><br><span class="line">  &#125;</span><br><span class="line">  T = DeleteMin(H); <span class="comment">//注意：此时堆中只有一个结点，这个节点即是哈夫曼树</span></span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算WPL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WPL</span><span class="params">(TreeNode *T, <span class="keyword">int</span> Depth)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((T-&gt;Left = <span class="literal">nullptr</span>) &amp;&amp; (T-&gt;Right == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Depth*(T-&gt;Weight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (WPL(T-&gt;Left, Depth + <span class="number">1</span>) + WPL(T-&gt;Right, Depth + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个完全二叉树调整成堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相关结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MinHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">  ElementType *Elements;</span><br><span class="line">  <span class="keyword">int</span> Size;</span><br><span class="line">  <span class="keyword">int</span> Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(MinHeap H)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = H-&gt;Size/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 从第一个有左子树的结点开始</span></span><br><span class="line">    PercDown(H, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下过滤函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(MinHeap H, <span class="keyword">int</span> Pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Parent, Child;</span><br><span class="line">  </span><br><span class="line">  ElementType X;</span><br><span class="line">  X = H-&gt;Elements[Pos];</span><br><span class="line">  <span class="keyword">for</span>(Parent = Pos; Parent * <span class="number">2</span> &lt;= H-&gt;Size; Parent = Child) &#123;</span><br><span class="line">    Child = Parent * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (Child != H-&gt;Size &amp;&amp; (H-&gt;Elements[Child] &gt; H-&gt;Elements[Child + <span class="number">1</span>]))</span><br><span class="line">Child++;</span><br><span class="line"><span class="keyword">if</span> (X &lt;= H-&gt;Elements[Child])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class="line">  &#125;</span><br><span class="line">  H-&gt;Elements[Parent] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;列举一些堆及相关操作的代码&lt;/p&gt;
&lt;p&gt;相关数据结构&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu环境挂载新硬盘</title>
    <link href="https://zhaoziwen.com.cn/archives/6c2d8b27.html"/>
    <id>https://zhaoziwen.com.cn/archives/6c2d8b27.html</id>
    <published>2019-05-06T04:37:21.000Z</published>
    <updated>2019-06-05T07:59:29.948Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、显示硬盘及所属分区情况。"><a href="#1、显示硬盘及所属分区情况。" class="headerlink" title="1、显示硬盘及所属分区情况。"></a>1、显示硬盘及所属分区情况。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/newdisk_1.png" alt="newdisk_1" title>                </div>                <div class="image-caption">newdisk_1</div>            </figure><h4 id="2、对硬盘进行分区。"><a href="#2、对硬盘进行分区。" class="headerlink" title="2、对硬盘进行分区。"></a>2、对硬盘进行分区。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/sdc</span><br></pre></td></tr></table></figure><p>在Command (m for help) 提示符后面输入n，执行 add a new partition 指令给硬盘增加一个新分区</p><p>接着在选择 Partition type 时键入 e，指定分区为扩展分区（extended）</p><p>出现 Partition number(1-4)时，输入1表示只分一个区</p><p>后续按默认值继续</p><p>在重新出现 Command (m for help) 提示符后输入p，显示分区表</p><p>无误后键入w，保存分区表</p><p>重新进行步骤一，正确操作显示如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/newdisk_2.png" alt="newdisk_2" title>                </div>                <div class="image-caption">newdisk_2</div>            </figure><h4 id="3、硬盘格式化"><a href="#3、硬盘格式化" class="headerlink" title="3、硬盘格式化"></a>3、硬盘格式化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdc # -t ext4 表示将分区格式化成ext4文件系统类型</span><br></pre></td></tr></table></figure><h4 id="4、挂载硬盘分区"><a href="#4、挂载硬盘分区" class="headerlink" title="4、挂载硬盘分区"></a>4、挂载硬盘分区</h4><p>显示硬盘挂载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -l</span><br></pre></td></tr></table></figure><p>挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t ext4 /dev/sdc /devdata</span><br></pre></td></tr></table></figure><p>重新查看挂载情况，如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/newdisk_3.png" alt="newdisk_3" title>                </div>                <div class="image-caption">newdisk_3</div>            </figure><h4 id="4、配置硬盘在系统启动自动挂载"><a href="#4、配置硬盘在系统启动自动挂载" class="headerlink" title="4、配置硬盘在系统启动自动挂载"></a>4、配置硬盘在系统启动自动挂载</h4><p>在文件/etc/fstab中加入如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdc/devdataext4defaults0 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、显示硬盘及所属分区情况。&quot;&gt;&lt;a href=&quot;#1、显示硬盘及所属分区情况。&quot; class=&quot;headerlink&quot; title=&quot;1、显示硬盘及所属分区情况。&quot;&gt;&lt;/a&gt;1、显示硬盘及所属分区情况。&lt;/h4&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="环境配置" scheme="https://zhaoziwen.com.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="ubuntu" scheme="https://zhaoziwen.com.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Permutations I &amp; II</title>
    <link href="https://zhaoziwen.com.cn/archives/3d4e0afa.html"/>
    <id>https://zhaoziwen.com.cn/archives/3d4e0afa.html</id>
    <published>2019-04-23T16:35:32.000Z</published>
    <updated>2019-06-05T07:59:29.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 46. Permutations</p><p>Given a collection of distince integers, return all possible permutations</p><p>Example:</p><p>Input: [1, 2, 3]</p><p>Output: </p><p>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><blockquote><p>[LeetCode] 47. Permutations II</p><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations</p><p>Example:</p><p>Input: [1, 1, 2]</p><p>Output: </p><p>[</p><p>  [1,1,2],</p><p>  [1,2,1],</p><p>  [2,1,1]</p><p>]</p></blockquote><p>此题使用深度优先搜索DFS来求解，从左到右依次向out加入之前没有加入的元素，直到level等于num的数目大小，将out加入结果。其中，用visited数组来表示该元素是否被使用过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out, visited(num.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="meta"># sort(nums.begin(), nums.end());    ## For II</span></span><br><span class="line">        permuteDFS(num, <span class="number">0</span>, visited, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteDFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == num.size()) &#123;res.push_back(out); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="meta"># <span class="meta-keyword">if</span>(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; visited[i - 1] == 0) continue; ## For II</span></span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            out.push_back(num[i]);</span><br><span class="line">            permuteDFS(num, level + <span class="number">1</span>, visited, out, res);</span><br><span class="line">            out.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中第二行注释的代码表示如果这个元素跟前一个元素相等，并且前一个元素已经访问过了(visited = 0)，就跳过避免重复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 46. Permutations&lt;/p&gt;
&lt;p&gt;Given a collection of distince integers, return all possible permutations&lt;/p&gt;
&lt;p&gt;Example:
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Sum of Two Integers</title>
    <link href="https://zhaoziwen.com.cn/archives/f79eb474.html"/>
    <id>https://zhaoziwen.com.cn/archives/f79eb474.html</id>
    <published>2019-04-23T15:30:37.000Z</published>
    <updated>2019-06-05T07:59:29.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 371. Sum of Two Integers</p><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p><p>Example 1:</p><p>Input: a = 1, b = 2</p><p>Output: 3</p><p>Example 2:</p><p>Input: a = -2, b = 3</p><p>Output: 1</p></blockquote><p>在十进制中，对于5+17=22这个结果，我们可以分为三步：</p><ol><li>只做各位相加不进位，此时相加的结果是12</li><li>只做进位，5+7中有进位，进位是10</li><li>把前面两个结果加起来，结果正好等于22</li></ol><p>在二进制中同理，5的二进制是101，17的二进制是10001</p><ol><li>各位相加但不进位，得到的结果是10100</li><li>记下进位，此例中只有最后一位相加时产生一个进位，结果是二进制的10</li><li>把前两部的结果相加，结果是10110，正好是22</li></ol><p>把二进制上的加法用位运算来替代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> num1 = a ^ b;</span><br><span class="line">  <span class="keyword">int</span> num2 = (a &amp; b)&amp;(<span class="number">0x7FFFFFFF</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> getSum(num1, num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：0x7FFFFFFF的作用是为了解决当a = -1, b = 1时，left shift操作错误(对于-2147483648)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 371. Sum of Two Integers&lt;/p&gt;
&lt;p&gt;Calculate the sum of two integers a and b, but you are not allowed to use the ope
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Multiply Strings</title>
    <link href="https://zhaoziwen.com.cn/archives/e10ee89c.html"/>
    <id>https://zhaoziwen.com.cn/archives/e10ee89c.html</id>
    <published>2019-04-22T15:32:59.000Z</published>
    <updated>2019-06-05T07:59:29.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 43. Multiply Strings</p><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p><p>Example 1:</p><p>Input: num1 = “2”, num2 = “3”</p><p>Output: “6”</p><p>Example 2:</p><p>Input: num1 = “123”, num2 = “456”</p><p>Output: “56088”</p></blockquote><p>这题看似简单，但是就是写不出来…</p><p>两数相乘的乘积的长度正好是两个数字的长度之和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> m = num1.size(), n = num2.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals(m+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">int</span> mul = (num1[i] - <span class="string">'0'</span>) * (num2[j] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>, sum = mul + vals[p2];</span><br><span class="line">        vals[p1] += sum / <span class="number">10</span>;</span><br><span class="line">        vals[p2] = sum % <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : vals) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!res.empty() || val != <span class="number">0</span>) res.push_back(val + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.empty() ? <span class="string">"0"</span> : res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单记录一下，这题其实就是检验写代码的能力，很可惜现在还不能把代码写的间接明了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 43. Multiply Strings&lt;/p&gt;
&lt;p&gt;Given two non-negative integers num1 and num2 represented as strings, return the prod
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>POSIX信号</title>
    <link href="https://zhaoziwen.com.cn/archives/bd1d3b91.html"/>
    <id>https://zhaoziwen.com.cn/archives/bd1d3b91.html</id>
    <published>2019-04-18T16:17:25.000Z</published>
    <updated>2019-06-05T07:59:29.952Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器子进程终止时，给父进程发送一个SIGCHLD信号。由于父进程未加处理，子进程进入僵死状态。</p><h4 id="POSIX信号处理"><a href="#POSIX信号处理" class="headerlink" title="POSIX信号处理"></a>POSIX信号处理</h4><p>信号就是告知某个进程发生了某个事件的通知，有时也成为软件中断(interrupt)</p><p>信号可以：</p><ol><li>由一个进程发送给另一个进程</li><li>由内核发送给某个进程</li></ol><p>每一个信号都有一个与之关联的处置(disposition)，也称为行为(action)。我们通过调用sigaction函数来设定一个信号的处置，并有三种选择：</p><ol><li>提供一个函数，在特定信号发生时就被调用。这样的函数被称为信号处理函数，这种行为称为捕获信号。但是有两个信号不同被捕获，即SIGKILL和SIGSTOP。</li><li>可以把某个信号的处置设定为SIG_IGN来忽略它。SIGKILL和SIGSTOP这两个信号不能被忽略。</li><li>把某个信号的处置设定为SIG_DFL来启用它的默认处置。</li></ol><h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><p>简历信号处置的POSIX方法就是调用sigaction函数，简单些的方法就是调用signal函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include signal */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line">Sigfunc *</span><br><span class="line">signal(<span class="keyword">int</span> signo, Sigfunc *func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span><span class="title">act</span>, <span class="title">oact</span>;</span></span><br><span class="line"></span><br><span class="line">act.sa_handler = func;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>SA_INTERRUPT</span></span><br><span class="line">act.sa_flags |= SA_INTERRUPT;<span class="comment">/* SunOS 4.x */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#ifdefSA_RESTART</span><br><span class="line">act.sa_flags |= SA_RESTART;<span class="comment">/* SVR4, 44BSD */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sigaction(signo, &amp;act, &amp;oact) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>(SIG_ERR);</span><br><span class="line"><span class="keyword">return</span>(oact.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end signal */</span></span><br><span class="line"></span><br><span class="line">Sigfunc *</span><br><span class="line">Signal(<span class="keyword">int</span> signo, Sigfunc *func)<span class="comment">/* for our signal() function */</span></span><br><span class="line">&#123;</span><br><span class="line">Sigfunc*sigfunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (sigfunc = signal(signo, func)) == SIG_ERR)</span><br><span class="line">err_sys(<span class="string">"signal error"</span>);</span><br><span class="line"><span class="keyword">return</span>(sigfunc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4-5行：函数signal的正常函数原型因层次太多而变得很复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>为了简化，在unp.h中定义了如下类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>说明信号处理函数是仅有一个整数参数且不返回值的函数。于是signal变为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sigfunc *<span class="title">signal</span><span class="params">(<span class="keyword">int</span> signo, Sigfunc *func)</span></span>;</span><br></pre></td></tr></table></figure><p>第10行：POSIX允许我们指定一组信号，在信号处理函数被调用时阻塞。任何阻塞的信号都不同递交给进程。把sa_mask成员函数设置为空，以为着在该信号函数运行期间，不阻塞额外信号。POSIX保证被捕获的信号在其信号处理函数运行期间总是阻塞的</p><h5 id="POSIX信号语义"><a href="#POSIX信号语义" class="headerlink" title="POSIX信号语义"></a>POSIX信号语义</h5><ol><li>一旦安装了信号处理函数，它便一直安装着</li><li>在一个信号处理函数运行期间，正被递交的信号是阻塞的。而且，安装处理函数在传递给sigaction函数的sa_mask信号集中指定的额外信号也被阻塞</li><li>如果一个信号在被阻塞期间产生了一次或多次，那些该信号被解阻塞之后通常只递交一次，也就是说Unix信号不排队</li><li>利用sigprocmask函数选择性的阻塞或解阻塞一组信号是可能的</li></ol><h4 id="处理SIGCHLD信号"><a href="#处理SIGCHLD信号" class="headerlink" title="处理SIGCHLD信号"></a>处理SIGCHLD信号</h4><h5 id="处理僵死进程"><a href="#处理僵死进程" class="headerlink" title="处理僵死进程"></a>处理僵死进程</h5><p>在之前的代码中的listen调用之后增加如下函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">Signal(SIGCHLD, sig_chld);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>接着定义sig_chld这个信号处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sig_chld(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pid_t</span>pid;</span><br><span class="line"><span class="keyword">int</span>stat;</span><br><span class="line"></span><br><span class="line">pid = wait(&amp;stat);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child %d terminated\n"</span>, pid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="处理被中断的系统调用"><a href="#处理被中断的系统调用" class="headerlink" title="处理被中断的系统调用"></a>处理被中断的系统调用</h5><p>当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。有些内核自动重启某些被中断的系统调用，为了移植方便，我们的捕获信号的程序需对返回的EINTR有所准备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">  clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">  <span class="keyword">if</span>((connfd = accept(listnfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      err_sys(<span class="string">"accept error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure><p>如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。</p><p>waitpid给了更多控制，pid参数允许我们指定想等待的进程ID，-1表示等待第一个终止的子进程。options参数的WNOHANG告知内核在没有已终止子进程时不要阻塞。</p><p>同时建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程：例如客户同时与服务器产生了5个连接，并在同一时刻退出，5个信号都在信号处理函数执行之前产生，而信号处理函数只执行一次，因为Unix信号一般不排队。并且，信号处理函数处理几次并不一定。</p><p>waitpid可以解决这个问题。可以防止wait在正运行的子进程尚有未终止时阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sig_chld(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pid_t</span>pid;</span><br><span class="line"><span class="keyword">int</span>stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( (pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child %d terminated\n"</span>, pid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即本节的目的：</p><ol><li>当fork子进程时，必须捕获SIGCHLD信号</li><li>当捕获信号时，必须处理被中断的系统调用</li><li>SIGCHLD的信号处理函数必须正确编写，使用waitpid函数以免留下僵死进程</li></ol><h4 id="SIGPIPE信号"><a href="#SIGPIPE信号" class="headerlink" title="SIGPIPE信号"></a>SIGPIPE信号</h4><p>当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号，该信号的默认行为是终止进程，因为进程必须捕获它以免不情愿被终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">str_cli(FILE *fp, <span class="keyword">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">Writen(sockfd, sendline, <span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">Writen(sockfd, sendline+<span class="number">1</span>, <span class="built_in">strlen</span>(sendline)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">err_quit(<span class="string">"str_cli: server terminated prematurely"</span>);</span><br><span class="line"></span><br><span class="line">Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次把文本行数据的第一个字节写入套接字，暂停1s后，第二次把同一文本行中剩余字节写入套接字，目的是让第一次writen引发一个RST，第二个writen产生SIGPIPE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在服务器子进程终止时，给父进程发送一个SIGCHLD信号。由于父进程未加处理，子进程进入僵死状态。&lt;/p&gt;
&lt;h4 id=&quot;POSIX信号处理&quot;&gt;&lt;a href=&quot;#POSIX信号处理&quot; class=&quot;headerlink&quot; title=&quot;POSIX信号处理&quot;&gt;&lt;/a&gt;PO
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UNIX网络编程" scheme="https://zhaoziwen.com.cn/tags/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Lowest Common Ancestor of a Binary Tree</title>
    <link href="https://zhaoziwen.com.cn/archives/1950a94b.html"/>
    <id>https://zhaoziwen.com.cn/archives/1950a94b.html</id>
    <published>2019-04-15T16:27:43.000Z</published>
    <updated>2019-06-05T07:59:29.945Z</updated>
    
    <content type="html"><![CDATA[<p>这里有两个题类似，一个是在二叉查找树的条件下，另一个是在普通二叉树条件下</p><blockquote><p>[LeetCode] 235. Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p>[LeetCode] 236. Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/binarytree.png" alt="binarytree" title>                </div>                <div class="image-caption">binarytree</div>            </figure></blockquote><p>其实236这个题在之前自己已经解决过了，但是反而到了235题没有成功解出来，可能的原因是题意理解错了，以为是找他们值最小的那个父节点。</p><p>之前236题自己的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">bool</span> p_dir = exist_subtree(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">bool</span> q_dir = exist_subtree(root-&gt;left, q);</span><br><span class="line">        <span class="keyword">if</span>(p_dir &amp;&amp; q_dir) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p_dir &amp;&amp; !q_dir) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist_subtree</span><span class="params">(TreeNode* root, TreeNode* a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == a-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(exist_subtree(root-&gt;left,a)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(exist_subtree(root-&gt;right,a)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在比较好的通用解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意第4行的返回情况，简洁的边界处理、多种情况的巧妙融合是需要自己接下来继续努力的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里有两个题类似，一个是在二叉查找树的条件下，另一个是在普通二叉树条件下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[LeetCode] 235. Given a binary search tree (BST), find the lowest common ancesto
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>基本TCP套接字编程</title>
    <link href="https://zhaoziwen.com.cn/archives/6dc0e616.html"/>
    <id>https://zhaoziwen.com.cn/archives/6dc0e616.html</id>
    <published>2019-04-13T11:51:39.000Z</published>
    <updated>2019-06-07T10:26:24.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础源码-请求日期和时间"><a href="#基础源码-请求日期和时间" class="headerlink" title="基础源码(请求日期和时间)"></a>基础源码(请求日期和时间)</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>sockfd, n;</span><br><span class="line"><span class="keyword">char</span>recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span><span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">err_quit(<span class="string">"usage: a.out &lt;IPaddress&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">"socket error"</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_port   = htons(<span class="number">13</span>);<span class="comment">/* daytime server */</span></span><br><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">err_quit(<span class="string">"inet_pton error for %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">"connect error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( (n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">recvline[n] = <span class="number">0</span>;<span class="comment">/* null terminate */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">err_sys(<span class="string">"fputs error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">err_sys(<span class="string">"read error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>listenfd, connfd;</span><br><span class="line"><span class="keyword">socklen_t</span>len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span><span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="keyword">char</span>buff[MAXLINE];</span><br><span class="line"><span class="keyword">time_t</span>ticks;</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family      = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port        = htons(<span class="number">13</span>);<span class="comment">/* daytime server */</span></span><br><span class="line"></span><br><span class="line">Bind(listenfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞服务器</span></span><br><span class="line"><span class="comment">// for ( ; ; ) &#123;</span></span><br><span class="line"><span class="comment">// len = sizeof(cliaddr);</span></span><br><span class="line"><span class="comment">// connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sleep(5);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// printf("connection from %s, port %d\n",</span></span><br><span class="line"><span class="comment">//    Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, sizeof(buff)),</span></span><br><span class="line"><span class="comment">//    ntohs(cliaddr.sin_port));</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//        ticks = time(NULL);</span></span><br><span class="line"> <span class="comment">//        snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&amp;ticks));</span></span><br><span class="line"> <span class="comment">//        Write(connfd, buff, strlen(buff));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Close(connfd);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">Close(listenfd);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection from %s, port %d\n"</span>,</span><br><span class="line">   Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, <span class="keyword">sizeof</span>(buff)),</span><br><span class="line">   ntohs(cliaddr.sin_port));</span><br><span class="line">ticks = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">"%.24s\r\n"</span>, ctime(&amp;ticks));</span><br><span class="line">Write(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">Close(connfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="部分函数解释"><a href="#部分函数解释" class="headerlink" title="部分函数解释"></a>部分函数解释</h4><h5 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h5><p>执行网络I/O的进程必须做的第一件事情</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>family常值：</p><p>​    IPv4协议：AF_INET</p><p>​    IPv6协议：AF_INET6</p><p>type常值：</p><p>​    字节流套接字：SOCK_STREAM</p><p>​    数据报套接字：SOCK_DGRAM</p><p>protocol常值：</p><p>​    TCP传输协议：IPPROTO_CP</p><p>​    UDP传输协议：IPPROTO_UDP</p><p>返回值：</p><p>​    成功时返回一个小的非负整数值，称为套接字描述符，简称sockfd</p><h5 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h5><p>TCP客户用connect函数来建立与TCP服务器的连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>出错返回情况：</p><p>1、一定时间内没有收到SYN分节的响应，返回ETIMEDOUT错误</p><p>2、若对SYN的响应是RST，表明该服务器主机在指定端口上没有进程在等待与之连接。返回ECONNREFUSED错误</p><p>3、客户发出的SYN在中间的某个路由器上引发了一个”destination unreachable”ICMP错误。若在一段时间内仍未收到响应，则返回EHOSTUNREACH或ENETUNREACH错误</p><h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h5><p>把一个本地协议地址赋予一个套接字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socken_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>对于IPv4，同配地址由常值INADDR_ANY来指定，其值一般为0</p><p>对于IPv6，因为128位的IPv6地址是存放在一个结构中的。(在C语言中，赋值语句的右边无法表示常值结构)，则可以改写为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure><p>系统预先分配in6addr_any变量并将其初始化为常值IN6ADDR_ANY_INIT。头文件&lt;netinet/in.h&gt;中含有in6addr_any的extern声明(0的网络字节序和主机字节序一样，所以没用htonl)</p><h5 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h5><p>listen函数仅由TCP服务器调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个参数规定了内核应该为相应套接字排队的最大连接个数</p><p>该函数在socket和bind之后调用，在accept之前调用</p><h5 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h5><p>accept函数由TCP服务器调用，用于从已完成连接队列头返回下一个已完成连接。如果为空，则投入睡眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>它的第一个参数为监听套接字描述符，返回值为已连接套接字描述符</p><h5 id="fork和exec函数"><a href="#fork和exec函数" class="headerlink" title="fork和exec函数"></a>fork和exec函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>fork函数调用一次，返回两次。在调用进程(父进程)返回一次，返回值为新派生的进程(子进程)的进程ID号。在子进程又返回一次，返回值为0</p><h5 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h5><p>典型的并发服务器程序轮廓：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">Bind(listenfd, ...);</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">  connfd = Accept(listenfd, ...);</span><br><span class="line">  <span class="keyword">if</span>((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="getsockname和getpeername函数"><a href="#getsockname和getpeername函数" class="headerlink" title="getsockname和getpeername函数"></a>getsockname和getpeername函数</h5><p>返回与某个套接字关联的本地协议地址(getsockname)或者返回与某个套接字关联的外地协议地址(getpeername)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>例子：获取套接字的地址族</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockfd_to_family</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">  <span class="keyword">socken_t</span> len;</span><br><span class="line">  len = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">  <span class="keyword">if</span>(getsockname(sockfd, (SA *) &amp;ss, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span>(ss.ss_family);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基础源码-请求日期和时间&quot;&gt;&lt;a href=&quot;#基础源码-请求日期和时间&quot; class=&quot;headerlink&quot; title=&quot;基础源码(请求日期和时间)&quot;&gt;&lt;/a&gt;基础源码(请求日期和时间)&lt;/h4&gt;&lt;h5 id=&quot;客户端&quot;&gt;&lt;a href=&quot;#客户端&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp" scheme="https://zhaoziwen.com.cn/tags/tcp/"/>
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UNIX网络编程" scheme="https://zhaoziwen.com.cn/tags/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Partition Equal Subset Sum</title>
    <link href="https://zhaoziwen.com.cn/archives/4f8bcd89.html"/>
    <id>https://zhaoziwen.com.cn/archives/4f8bcd89.html</id>
    <published>2019-04-03T17:05:06.000Z</published>
    <updated>2019-06-05T07:59:29.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 416. Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p>Note:</p><ol><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p>Example1:</p><p>Input: [1, 5, 11, 5]</p><p>Output: true</p><p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p></blockquote><p>万事不决用DP！</p><p>首先原数组所有数字和一定是偶数，不然无法拆分成2个和相同的子集和。所以我们只需要算出原数组的和，然后除以2，就是我们的target，即将问题转化为能不能找到一个非空子集，使得其和为target。</p><p>此处我们定义一个一维dp数组，其中dp[i]表示原数组是否可以取出若干个数字，其和为i。初始状态dp[0]为true，因为题中限制了所有数字为正数。</p><p>我们需要遍历原数组中的数字，对于遍历到的每个数字nums[i]，需要更新dp数组，我们的最终目标是想知道dp[target]的bool值，就要想办法用数组中的数字去凑出target，因为都是正数，结果会越来越大，那么加上nums[i]就有可能会组成区间[nums[i], target]中的某个值，那么对于这个区间中的任意一个数字j，如果dp[j - nums[i]]为true，说明现在已经可以组成j-nums[i]这个值，再加上nums[i]，就可以组成数字j，那么dp[j]就一定为true。所以状态转移方程为：<br>$$<br>dp[j]\ =\ dp[j]\ ||\ dp[j\ -\ nums[i]]\ \ \ \ (nums[i]\ &lt;=\ j\ &lt;=\ target)<br>$$<br>需要特别注意的是：第二个for循环一定要从target遍历到nums[i]，不能反过来，因为如果从nums[i]到target，假如nums[i] = 1，那[1, target]所有dp的值都为true，因为dp[0] = true，dp[1] = dp[1] || dp[0] 也为true… 同时也是为了防止同一元素被多次利用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>), target = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(target + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = target; i &gt;= num; --i) &#123;</span><br><span class="line">        dp[i] = dp[i] || dp[i - num];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 416. Given a non-empty array containing only positive integers, find if the array can be partitioned into two sub
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Burst Balloons</title>
    <link href="https://zhaoziwen.com.cn/archives/7364d39f.html"/>
    <id>https://zhaoziwen.com.cn/archives/7364d39f.html</id>
    <published>2019-04-02T15:48:10.000Z</published>
    <updated>2019-06-05T07:59:29.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 312. Burst Balloons</p><p>Given n ballons, indexed from 0 to n-1. Each ballon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst ballon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p><p>Find the maximum coins you can collect by bursting the balloons wisely.</p><p>Note:</p><ul><li>You may imagine nums[-1] = nums[n] = 1</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li></ul><p>Example:</p><p>Input: [3, 1, 5, 8]</p><p>Ouput: 167</p><p>Explanation: nums = [3, 1, 5, 8] –&gt; [3, 5, 8] –&gt; [3, 8] –&gt; []</p><p>coins = 3 * 1 * 5 + 3 * 5 * 8 + 1 * 3 * 8 + 1 * 8 * 1 = 167</p></blockquote><p>这道题的解题思路仍是动态规划，与经典的矩阵连乘相似。</p><p>维护一个二维动态数组dp，其中dp[i][j]表示打爆区间[i,j]中的所有气球能得到的最多金币。在这个区间中，遍历其中的K，加入第K个气球先被打爆，然后区间[i,j]被分成了两部分，[i,k-1]和[k+1,j]。所以递推公式如下：<br>$$<br>dp[i][j] = max(dp[i][j], nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j])                 ( i ≤ k ≤ j )<br>$$<br>其中，遍历的顺序为：</p><p>[3] -&gt; [1] -&gt; [5] -&gt; [8] -&gt; [3, 1] -&gt; [1, 5] -&gt; [5, 8] -&gt; [3, 1, 5] -&gt; [1, 5, 8] -&gt; [3, 1, 5, 8]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">        nums.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], nums[i - <span class="number">1</span>] * nums[k] * nums[j + <span class="number">1</span>] + dp[i][k - <span class="number">1</span>] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 312. Burst Balloons&lt;/p&gt;
&lt;p&gt;Given n ballons, indexed from 0 to n-1. Each ballon is painted with a number on it rep
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>传输控制协议TCP概述</title>
    <link href="https://zhaoziwen.com.cn/archives/b597af2c.html"/>
    <id>https://zhaoziwen.com.cn/archives/b597af2c.html</id>
    <published>2019-04-01T17:08:31.000Z</published>
    <updated>2019-06-07T10:26:23.381Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP主要特点"><a href="#TCP主要特点" class="headerlink" title="TCP主要特点"></a>TCP主要特点</h4><ol><li>TCP是<strong>面向连接的运输层协议</strong>。意味着在使用TCP之前，必须要先建立TCP连接；在完成数据传送后，释放已经建立的TCP连接。</li><li>每一条TCP连接只能有<strong>两个端点(endpoint)</strong>，即TCP连接是<strong>点对点</strong>的。</li><li>TCP提供<strong>可靠交付</strong>的服务。</li><li>TCP提供<strong>全双工通信</strong>。</li><li><strong>面向字节流</strong>。TCP并不关心应用程序一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定应该包含多少个字节（与UDP不同，由应用程序给出）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_1.png" alt="tcp_1" title>                </div>                <div class="image-caption">tcp_1</div>            </figure></li></ol><h4 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h4><p>TCP连接的端点叫做<strong>套接字(socket)</strong>，即由端口号拼接到IP地址后面构成，例如：192.3.4.5:80，每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定</p><h4 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h4><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认，在收到确认之后再发送下一个分组。</p><ol><li><p>无差错情况(a)</p><p> <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_2.png" alt="tcp_2"></p></li></ol><ol start="2"><li><p>出现差错(b)</p><ol><li>A在发送完一个分组后，<strong>暂时保留已发送的分组的副本</strong>，收到相应确认后消除副本。</li><li>分组和确认分组必须进行编号。</li><li>超时计时器设置的重传时间<strong>应当比数据在分组传输的平均时间更长一些</strong>。</li></ol></li><li><p>确认丢失和确认迟到</p><ol><li><p>确认丢失</p><ol><li>丢弃这个重复的分组，不向上交付。</li><li>向A发送确认</li></ol></li><li><p>确认迟到</p><ol><li>A收到重复确认后丢弃。</li><li>B收到重复的分组后按确认丢失处理。</li></ol><p>上述这种可靠的传输协议常称为<strong>自动重传请求ARQ(Automatic Repeat reQuest)</strong></p><p><img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_3.png" alt="tcp_3"></p></li></ol></li></ol><ol start="4"><li><p>信道利用率</p><p> <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_4.png" alt="tcp_4"></p><p>$$<br>U=\frac{T_{D}}{T_{D} + RTT + T_{A}<br>$$ </p><p> 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输，该方式会使用<strong>连续ARQ协议</strong>和<strong>滑动窗口协议</strong>。</p><p> <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_5.png" alt="tcp_5"></p></li></ol><h5 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_6.png" alt="tcp_6" title>                </div>                <div class="image-caption">tcp_6</div>            </figure><p>发送方每收到一个确认，就把发送窗口向前滑动一个分组。接收方一般是采用<strong>累计确认</strong>的方式，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组之后，对<strong>按序到达的最后一个分组发送确认</strong>。</p><h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><p>TCP报文段首部的前20个字节是固定的(如下图)，后面有4n字节是根据需要而增加的选项。因此TCP首部的最小长度是20字节。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_7.png" alt="tcp_7" title>                </div>                <div class="image-caption">tcp_7</div>            </figure><p>各字段意义如下：</p><ol><li><p>源端口和目的端口。</p></li><li><p>序号。范围是$[0, 2^{32} - 1]$，在一个TCP连接中传送的字节流中的每一个字节都按序编号。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>确认号。是期望收到对方下一个报文段的第一个数据字节的序号。若确认号 = N，则表明：到序号N - 1为止的所有数据都已正确收到。</p></li><li><p>数据偏移。指的是TCP报文段的数据起始处距离TCP报文段的起始处有多远。实际上是指TCP报文段的首部长度。”数据偏移”的单位是32位字(即4字节)。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移最大值是50字节。也是TCP首部的最大长度。</p></li><li><p>保留。保留为今后使用，目前应置为0。后跟6个控制位。</p></li><li><p>紧急URG(URGent)。当URG=1时，表明紧急指针字段有效。系统应尽快传送此报文段。</p></li><li><p>确认ACK(ACKnowledgment)。当ACK=1时，表名确认号字段有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置为1。</p></li><li><p>推送PSH(PuSH)。发送方TCP把PSH置1时，接收方TCP收到PSH=1的报文段，就尽快地交付接受应用进程，而不再等到整个缓存都填满了后再向上交付。</p></li><li><p>复位RST(ReSeT)。当RST=1时，表示TCP连接中出现严重错误，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或者拒绝打开一个连接。</p></li><li><p>同步SYN(SYNchronization)。在连接建立是用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</p></li><li><p>终止FIN(FINis)。用来释放一个连接，置为1是生效，请求释放运输连接。</p></li><li><p>窗口。窗口指的是发送本报文段的一方的<strong>接受窗口</strong>。窗口值告诉对方：从本报文段首部的确认号算起，接收方目前允许对方发送的数据量(字节为单位)。</p></li><li><p>检验和。范围包括首部和数据两部分。和UDP一样在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。格式与UDP一样，应把第4个字段改为6，第5个字段中的UDP长度改为TCP长度。</p></li><li><p>紧急指针。仅在URG=1时才有意义，指出本报文段中的紧急数据的字节数，即紧急指针指出了紧急数据的末尾在报文段中的位置。</p></li><li><p>选项。最长40字节。没有使用是，TCP的首部长度为20字节。</p><p>最初TCP只规定一种选项，即<strong>最大报文段长度MSS（Maximum Segment Size）</strong>，即数据字段的最大长度。</p><p>随后增加了<strong>窗口扩大、时间戳、选择确认（ASCK）</strong>等选项</p></li></ol><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><h5 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h5><p>TCP的滑动窗口以字节为单位，下面讨论A向B发送数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_8.png" alt="tcp_8" title>                </div>                <div class="image-caption">tcp_8</div>            </figure><p>发送窗口的后沿的变化有两种，即不动(没有收到新的确认)和前移(收到了新的确认)。前沿也有两种，不断前移和不动(没有收到新的确认或者收到新的确认同时接收方窗口变小)。</p><h5 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h5><p>TCP采用了一种自适应算法，每测量到一个新的RTT样本，就按下式重新计算一次$RTT_{S}$(加权平均往返时间)：<br>$$<br>新的RTT_{S} = (1 - α) * (旧的RTT_{S}) + α * (新的RTT样本)<br>$$<br>建议标准值为1/8即0.125。</p><p>所以，超时计时器设置的超时重传时间RTO(RetransmissionTime-Out)应略大于上面得出的加权平均往返时间$RTT_{S}$。建议计算式如下：<br>$$<br>RTO = RTT_{S} + 4 * RTT_{D}<br>$$<br>而$RDD_{D}$是RTT的偏差的加权平均值，与$RTT_{S}$和新的RTT样本之差有关。建议计算式如下：</p><p>第一次测量时，$RTT_{D}$值取为测量到的RTT样本值的一半，在以后的测量中：<br>$$<br>新的RTT_{D}=(1-β) * (旧的RTT_{D})+β * | RTT_{S}-新的RTT样本|<br>$$<br>这里β的推荐值是1/4，即0.25。</p><p>为了解决无法确实确认报文段是对先发送的报文段的确认还是对后来重传的报文段的确认，<strong>在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本</strong>，同时进一步的修正：<strong>报文段每重传一次，就把超时重传时间RTO增加到原来的2倍，当不在发生重传时，才根据上式进行计算</strong>。</p><h5 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_9.png" alt="tcp_9" title>                </div>                <div class="image-caption">tcp_9</div>            </figure><p>和前后不连续的每一个字节块都有两个边界：左边界和右边界。左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号(与确认号类似)。</p><p>如果使用选择确认SACK，需要在建立连接时在TCP首部的选项中加入”允许SACK”的选项。由于首部选项最多只能40字节，而指明一个边界需要4字节，因此在选项中最多只能指明4个字节块的边界信息。其中还需要两个字节，一个用来指明是SACK选项，另一个指明这个选项占多少字节。</p><h4 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h4><h5 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_10.png" alt="tcp_10" title>                </div>                <div class="image-caption">tcp_10</div>            </figure><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出现在的窗口值。如果仍为0，就重新设置持续计时器。</p><h5 id="TCP的传输效率"><a href="#TCP的传输效率" class="headerlink" title="TCP的传输效率"></a>TCP的传输效率</h5><p>不同的机制来控制TCP报文段的发送时机：</p><ol><li>TCP维持一个变量，等于最大报文段长度MSS。</li><li>由发送发的应用进程指明要求发送报文段，即TCP支持的推送（push）操作。</li><li>发送方的一个计时期限到了，就把当前已有的缓存数据装入报文段（不超过MSS）发出去。</li></ol><p>Nagle算法：若发送应用程序吧要发送的数据逐个字节送到TCP发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到第一个数据字节的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去。同时，当到达的数据已达到发送窗口大小的一半或者已达到报文段的最大长度时，就立即发送一个报文段。</p><p>解决糊涂窗口综合征(接受缓存已满，应用程序每次只读取1个字节)，可以让接收方等待一段时间，使得接受缓存已有足够空间容纳一个最长的报文段，或者等到接受缓存已有一半空闲的空间。只要出现任何一种情况，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p><h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><h5 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h5><p>拥塞控制指的是防止过多的数据注入网络，使网络中的路由器或链路不致过载。</p><p>流量控制往往是指点对点通信量的控制，是个端到端的问题。抑制发送端的速率，以便接收端来得及接收。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_11.png" alt="tcp_11" title>                </div>                <div class="image-caption">tcp_11</div>            </figure><h5 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h5><p>TCP进行拥塞控制的算法有四种，即<strong>慢开始(slow-start)</strong>、<strong>拥塞避免(congestion avoidance)</strong>、<strong>快重传(fast retransmit)</strong>、<strong>快恢复(fast recovery)</strong></p><p>发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量，取决于网络的拥塞程度，并动态变化。发送方的发送窗口等于拥塞窗口。</p><p>原则：只要网络没有出现拥塞， 拥塞窗口就可以再增大一些。但只要出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些。判断网络拥塞的依据就是出现了超时。</p><p><strong>慢开始算法：</strong></p><p>初始拥塞窗口cwnd设置为不超过2至4个SMSS的数值。具体规定省略。</p><p>在每收到一个对新的报文段的确认之后，可以把拥塞窗口增加最多一个SMSS的数值。<strong>每经过一个传输轮次(transmission round)，拥塞窗口cwnd就加倍</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_12.png" alt="tcp_12" title>                </div>                <div class="image-caption">tcp_12</div>            </figure><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量：</p><p>当cwnd &lt; ssthresh时，使用慢开始算法</p><p>当cwnd &gt; ssthresh时，使用拥塞避免算法</p><p>当cwnd = ssthresh时，两种都可以</p><p><strong>拥塞避免：</strong></p><p>没经过一个往返RTT就把发送方的拥塞窗口cwnd加1，而不是成倍增长。</p><p>当出现超时时，调整ssthresh = cwnd / 2，并同时设置拥塞窗口cwnd = 1，进入慢开始阶段</p><p>当出现收到3个重复确认，应立即进行重传，并执行快恢复算法，即调整ssthresh = cwnd / 2，同时设置cwnd = ssthresh，并开始执行拥塞避免算法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_13.png" alt="tcp_13" title>                </div>                <div class="image-caption">tcp_13</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_14.png" alt="tcp_14" title>                </div>                <div class="image-caption">tcp_14</div>            </figure><h5 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h5><p>为了避免发生网络中的全局同步现象，AQM指在队列长度达到某个值得警惕的数值时就主动丢弃分组。<strong>随机早期检测RED(Random Early Detection)</strong>维持两个参数，即最小门限和最大门限：</p><p>若平均队列长度小于最小门限，新到达的分组放入队列进行排队。</p><p>若超过最大门限，则把新到达的分组丢弃。</p><p>若在之间，则按概率p丢弃。</p><h4 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h4><p>运输连接有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>、<strong>连接释放</strong></p><h5 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h5><p>握手需要在客户和服务器之间交换三个TCP报文段。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_15.png" alt="tcp_15" title>                </div>                <div class="image-caption">tcp_15</div>            </figure><p>最初两端的TCP进程都处于CLOSED状态。A(客户)主动打开连接，B(服务器)被动打开连接。</p><p>一开始，B的TCP服务器进程创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程处于LISTEN状态，等待客户的连接请求。</p><p>A的TCP客户端创建TCB，然后在打算建立TCP连接时，向B发出连接请求报文段，这是首部中的SYN=1，同时选择一个初始序号seq = x。SYN报文段(SYN=1的报文段)不能携带数据，但要消耗一个序号。这是TCP客户进程进入SYN-SENT状态。</p><p>B收到连接请求后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置为1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y。这个报文段也不能携带数据，但同样消耗一个序号。这是TCP服务器进程进入SYN-RCVD状态。</p><p>TCP客户进程收到B的确认之后，还要向B给出确认。确认报文段ACK=1，确认号ack = y + 1，而自己的序号seq = x + 1。ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x + 1。这时TCP连接已经建立，A进入ESTABLISHED状态。</p><p>当B收到A的确认后，也进入ESTABLISHED状态。</p><p>A最后发送一次确认的意义：为了防止已失效的连接请求报文段突然传送到B，因而产生错误。</p><h5 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_16.png" alt="tcp_16" title>                </div>                <div class="image-caption">tcp_16</div>            </figure><p>A和B都处于ESTABLISHED状态。</p><p>A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段的首部的终止控制位FIN置1，其序号seq = u，它等于前面已传送过的数据的最后一个字节加1。这时A进入FIN-WAIT-1状态，等待B的确认。FIN报文段即使不携带数据，也消耗一个序号。</p><p>B收到连接释放报文段后即发出确认，确认号是ack = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B进入CLOSE-WAIT状态。这是的TCP连接处于半关闭(half-close)状态，A已经没有数据发送了，但B若要发送数据，A仍要接受。即B到A这个方向的连接并未关闭。</p><p>A收到来自B的确认后，就进入FIN-WAIT-2状态，等待B发出的连接释放报文段。</p><p>若B已经没有要向A发送的数据，其应用程序就通知TCP释放连接。这时B发出的连接释放报文段必须使用FIN=1。现假定B的序号为w。B还必须重复上一次已发送过的确认号ack = u + 1。这时B就进入LAST-ACK状态，等待A的确认。</p><p>A收到B的连接释放报文段后，发出确认。在确认报文段中把ACK置为1，确认号ack = w + 1，而自己的序号seq = u + 1。然后进入TIME-WAIT状态。目前TCP连接仍未释放，必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSE状态。MSL叫做最长报文段寿命(Maximum Segment Lifetime)。</p><p>A在TIME-WAIT状态下等待2MSL的时间的意义：</p><ol><li>为了保证A发送的最后一个ACK报文段能够到达B。B在LAST-ACK状态收不到对已发送的FIN + ACK报文段的确认，便会超时重传。接着A再重传，重新启动2MSL计时器。</li><li>为了防止”已失效的连接请求报文”出现。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><p>除了等待计时器，TCP还有一个<strong>保活计时器(keepalive timer)</strong>。服务器每收到一次客户的数据，就重新设置该计时器。若10个探测报文段后仍无相应，就关闭连接。</p><h5 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h5><p>粗实线表示对客户进程的正常变迁。粗虚线箭头表示对服务器进程的正常变迁。另一种细线箭头表示异常变迁。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/tcp_17.png" alt="tcp_17" title>                </div>                <div class="image-caption">tcp_17</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCP主要特点&quot;&gt;&lt;a href=&quot;#TCP主要特点&quot; class=&quot;headerlink&quot; title=&quot;TCP主要特点&quot;&gt;&lt;/a&gt;TCP主要特点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;TCP是&lt;strong&gt;面向连接的运输层协议&lt;/strong&gt;。意味着在使用TCP之前，
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp" scheme="https://zhaoziwen.com.cn/tags/tcp/"/>
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock with Cooldown</title>
    <link href="https://zhaoziwen.com.cn/archives/ef219356.html"/>
    <id>https://zhaoziwen.com.cn/archives/ef219356.html</id>
    <published>2019-04-01T14:57:33.000Z</published>
    <updated>2019-06-05T07:59:29.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 309. Say you have an array for which the $i^{th}$element is the price of a given stock on day $i$.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like(ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time(ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cool down 1 day)</li></ul><p>Example:</p><p>Input: [1,2,3,0,2]</p><p>Output: 3</p><p>Explanation: transactions = [buy, sell, cooldown, buy, sell]</p></blockquote><p>这里的动态规划问题跟之前的稍有不同。</p><p>当前买卖股票的行为会受到之前日期买卖股票行为的影响。对一天的状态有：买入bug，卖出sell，冷却cooldown。</p><p>但是对于这一天是否持股只有两种状态：持股状态buy，没有持股状态sell, cooldown。</p><p>对于当天持股状态时，至当天为止的最大利润有两种可能：</p><ol><li><p>今天没有买入，跟昨天持股状态一样</p></li><li><p>今天买入，昨天是冷却期，利润是前天卖出股票时得到的利润减去今天股票的价钱。</p><p>二者取最大值。</p></li></ol><p>对于当天未持股状态，至当天为止的最大利润也有两种情况：</p><ol><li><p>今天没有卖出，跟昨天未持股状态一样</p></li><li><p>昨天持有股票，今天卖出了，例如是昨天持有股票时候的利润加上今天股票的价钱</p><p>二者取最大值</p></li></ol><p>直至最后一天的状态应该是卖出状态。最终利润是sell[n-1]。</p><p>状态转移方程：<br>$$<br>sell[i] = max(sell[i-1], buy[i-1]+price[i]);<br>$$<br>$$<br>buy[i] = max(buy[i-1], sell[i-1]-price[i]);<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre_bug = <span class="number">0</span>, pre_sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>], sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> price:prices) &#123;</span><br><span class="line">      pre_buy = buy;</span><br><span class="line">      buy = max(pre_buy, pre_sell-price); <span class="comment">// 此处的buy已经指到下一个，pre_buy更新为之前的buy，现在的buy的前一个，但是pre_sell没有更新，为现在的buy的前一个的前一个</span></span><br><span class="line">      pre_sell = sell;</span><br><span class="line">      sell = max(pre_sell, pre_buy+price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 309. Say you have an array for which the $i^{th}$element is the price of a given stock on day $i$.&lt;/p&gt;
&lt;p&gt;Design 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字典树(前缀树) Trie Tree(Prefix Tree)</title>
    <link href="https://zhaoziwen.com.cn/archives/64fec234.html"/>
    <id>https://zhaoziwen.com.cn/archives/64fec234.html</id>
    <published>2019-03-27T16:27:52.000Z</published>
    <updated>2019-06-05T07:59:29.953Z</updated>
    
    <content type="html"><![CDATA[<p>字典树是一种数据结构，用于处理大量的字符串，是一种哈希树的变种。典型应用是用于统计、排序和保存大量的字符串，经常被搜索引擎系统用于文本词频统计。优点在于利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><p>字典树有3个基本性质：</p><ol><li>根结点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根结点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><h4 id="实现如下："><a href="#实现如下：" class="headerlink" title="实现如下："></a>实现如下：</h4><p>首先定义TrieNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> content; <span class="comment">// the character in the node</span></span><br><span class="line">  <span class="keyword">boolean</span> isEnd; <span class="comment">// whether the end of the words</span></span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">//the number of words sharing this character</span></span><br><span class="line">  LinkedList&lt;TrieNode&gt; childList; <span class="comment">// the child list</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    childList = <span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">    isEnd = <span class="keyword">false</span>;</span><br><span class="line">    content = c;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> TrieNode <span class="title">subNode</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(childList != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(TrieNode eachChild : childList) &#123;</span><br><span class="line">        <span class="keyword">if</span>(eachChild.content == c) &#123;</span><br><span class="line">          <span class="keyword">return</span> eachChild;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    childList = <span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">    isEnd = <span class="keyword">false</span>;</span><br><span class="line">    content = <span class="string">' '</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是Trie类的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(search(word) == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">      TrieNode child = current.subNode(word.charAt(i));</span><br><span class="line">      <span class="keyword">if</span>(child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current = child;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        current.childList.add(<span class="keyword">new</span> TrieNode(word.charAt(i)));</span><br><span class="line">        current = current.subNode(word.charAt(i));</span><br><span class="line">      &#125;</span><br><span class="line">      current.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    current.isEnd = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current.subNode(word.charAt(i)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        current = current.subNode(word.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(current.isEnd == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current.subNode(word.charAt(i)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        current = current.subNode(word.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(search(word) == <span class="keyword">false</span>) <span class="keyword">return</span>;</span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">      TrieNode child = current.subNode(c);</span><br><span class="line">      <span class="keyword">if</span>(child.count == <span class="number">1</span>) &#123;</span><br><span class="line">        current.childList.remove(child);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        child.count--;</span><br><span class="line">        current = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current.isEnd = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字典树是一种数据结构，用于处理大量的字符串，是一种哈希树的变种。典型应用是用于统计、排序和保存大量的字符串，经常被搜索引擎系统用于文本词频统计。优点在于利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。&lt;/p&gt;
&lt;p&gt;字典树有3个基本性
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://zhaoziwen.com.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Maximal Square</title>
    <link href="https://zhaoziwen.com.cn/archives/a137f872.html"/>
    <id>https://zhaoziwen.com.cn/archives/a137f872.html</id>
    <published>2019-03-26T17:07:04.000Z</published>
    <updated>2019-06-05T07:59:29.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 221. Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example:</p><p>Input:</p><p>1 0 1 0 0</p><p>1 0 1 1 1</p><p>1 1 1 1 1</p><p>1 0 0 1 0</p><p>Output: 4</p></blockquote><p>这又是一道典型的DP题目，但是我依然没有任何思路。</p><p>解决办法：</p><p>首先考虑第一行和第一列，如果为’1’，则该位置上的DP数组为1，否则为0。</p><p>然后再考虑中间，以中间某个点为右下角的最大的正方形即为上方、左方和左上方为右下角的最大正方形中的最小值加一。</p><p>即动态规划递推式为：<br>$$<br>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = matrix[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 221. Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Course Schedule</title>
    <link href="https://zhaoziwen.com.cn/archives/ad252c61.html"/>
    <id>https://zhaoziwen.com.cn/archives/ad252c61.html</id>
    <published>2019-03-25T16:32:46.000Z</published>
    <updated>2019-06-05T07:59:29.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 207. Course Schedule</p><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prequisite pairs, is it possible for you to finish all courses?</p><p>Example 1:</p><p>Input: 2, [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.</p><p>Example 2:</p><p>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.</p></blockquote><p>很容易看出这是一道检测图是否有环的题，但是由于接触的图像的题较少，所以目前很难写出跟图有关的代码。所以记录一下过程。</p><p>这里在生成有向图之后，DFS和BFS都可以解决此题。目前先看BFS。</p><p>定义一个二维数组graph来表示这个有向图，一维数组in来表示每个顶点的入度(离散数学)。然后定义一个queue变量，将所有入度为0的点放入队列中，然后开始遍历队列，从graph里遍历其间接的点，每达到一个新节点，将其入度减一，如果此时改点入度为0，则放入队列末尾。知道遍历万队列中所有的值，若此时还有节点的入度不为0，则说明环存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; graph(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : prerequisites) &#123;</span><br><span class="line">            graph[a[<span class="number">1</span>]].push_back(a[<span class="number">0</span>]);</span><br><span class="line">            ++in[a[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : graph[t]) &#123;</span><br><span class="line">                --in[a];</span><br><span class="line">                <span class="keyword">if</span> (in[a] == <span class="number">0</span>) q.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中还有DFS的解法，待解决~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 207. Course Schedule&lt;/p&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n-1.&lt;/p&gt;
&lt;p&gt;Some c
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu初始化配置流程</title>
    <link href="https://zhaoziwen.com.cn/archives/360ed1a2.html"/>
    <id>https://zhaoziwen.com.cn/archives/360ed1a2.html</id>
    <published>2019-03-24T16:02:12.000Z</published>
    <updated>2019-06-05T07:59:29.954Z</updated>
    
    <content type="html"><![CDATA[<p>以下记录一下Ubuntu的配置流程，持续更新</p><blockquote><p>环境：ubuntu 16.04.6 Desktop</p></blockquote><h4 id="一、更新apt源"><a href="#一、更新apt源" class="headerlink" title="一、更新apt源"></a>一、更新apt源</h4><p>1、源文件备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>2、编辑源列表文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>3、将原来的列表删除，添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>4、更新源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h4 id="二、转换中文及安装搜狗输入法"><a href="#二、转换中文及安装搜狗输入法" class="headerlink" title="二、转换中文及安装搜狗输入法"></a>二、转换中文及安装搜狗输入法</h4><p>1、在Language Support中增加汉语，然后选择输入法系统为fcitx</p><p>2、重启系统</p><p>3、<a href="http://pinyin.sogou.com/linux" rel="external nofollow noopener noreferrer" target="_blank">打开官网</a>，下载安装包</p><p>4、终端运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_xxxx.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若出错则运行下面的命令</span></span><br><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure><p>5、重启</p><h4 id="三、为root账户设置密码已经切换至root账户"><a href="#三、为root账户设置密码已经切换至root账户" class="headerlink" title="三、为root账户设置密码已经切换至root账户"></a>三、为root账户设置密码已经切换至root账户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root #为root账户设置密码</span><br><span class="line">su root #切换至root账户</span><br></pre></td></tr></table></figure><h4 id="四、安装Anaconda"><a href="#四、安装Anaconda" class="headerlink" title="四、安装Anaconda"></a>四、安装Anaconda</h4><p>1、下载安装包</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" rel="external nofollow noopener noreferrer" target="_blank">历史版本</a>，该网页包含所有历史版本，其实5.2.0对应python3.6，5.3.0对应python3.5。</p><p>2、安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Downloads</span><br><span class="line">sh Anaconda3-xxx.sh</span><br></pre></td></tr></table></figure><p>3、添加环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line">export PATH=~/anaconda3/bin:$PATH #在最后一行加入</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>4、更换conda源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#第三方源</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Conda Forge</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">msys2</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">bioconda</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">menpo</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">pytorch</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure><p>5、更换pypi源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U #升级pip到最新的版本</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h4 id="五、安装git"><a href="#五、安装git" class="headerlink" title="五、安装git"></a>五、安装git</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h4 id="六、安装python3-6，并更改默认python版本"><a href="#六、安装python3-6，并更改默认python版本" class="headerlink" title="六、安装python3.6，并更改默认python版本"></a>六、安装python3.6，并更改默认python版本</h4><p>1、安装python3.6和pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装python3.6</span></span><br><span class="line">sudo add-apt-repository ppa:jonathonf/python-3.6</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装pip</span></span><br><span class="line">apt-get install python-pip # 此时的默认python应该是python3.6，所以应该先执行下面的更改默认python版本后再安装pip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 如果安装pip之后出错</span></span></span><br><span class="line">vim /usr/bin/pip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改内容如下</span></span></span><br><span class="line">//修改前</span><br><span class="line">from pip import main</span><br><span class="line">if __name__ == '__main__': </span><br><span class="line">sys.exit(main()) </span><br><span class="line">//修改后 from pip import __main__   //这行也要修改</span><br><span class="line">if __name__ == '__main__': </span><br><span class="line">sys.exit(__main__._main())  //增加__main__._</span><br></pre></td></tr></table></figure><p>2、更改默认python版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统中可用的Python二进制文件</span></span><br><span class="line">ls /usr/bin/python*</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Output:</span></span></span><br><span class="line">/usr/bin/python            /usr/bin/python2-config  /usr/bin/python3.6</span><br><span class="line">/usr/bin/python2           /usr/bin/python3         /usr/bin/python3.6m</span><br><span class="line">/usr/bin/python2.7         /usr/bin/python3.5       /usr/bin/python3m</span><br><span class="line">/usr/bin/python2.7-config  /usr/bin/python3.5m      /usr/bin/python-config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更换至root账户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 罗列出所有可用的python替代版本的信息</span></span><br><span class="line">update-alternatives --list python</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Output:</span></span></span><br><span class="line">update-alternatives: error: no alternatives for python</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新替代列表</span></span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.5 2</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.6 3</span><br></pre></td></tr></table></figure><p>即替换成功，其中最后一个参数为优先级，数字越大，优先级越高</p><h4 id="七、科学上网"><a href="#七、科学上网" class="headerlink" title="七、科学上网"></a>七、科学上网</h4><p>下面的流程基于ssr协议，此协议兼容原版ss协议。</p><p>1、下载ssr客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ssrbackup/shadowsocksr</span><br></pre></td></tr></table></figure><p>2、配置ss文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd shadowsocksr</span><br><span class="line">cp config.json /etc/shadowsocks.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照ssr的参数对下面的文件进行配置</span></span><br><span class="line">sudo vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>3、启动ssr客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shadowsocks/local.py -c /etc/shadowsocks.json # 此处python的版本为python3</span><br></pre></td></tr></table></figure><p>4、转换HTTP代理</p><p>shadowsocks默认是用sock5协议的，对于终端的get、wget等走的是http协议的地方是无能为力的，所以需要转换成http代理，这里基于Polipo。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo # 安装Polipo</span><br><span class="line">sudo vim /etc/polipo/config # 修改配置文件</span><br></pre></td></tr></table></figure><p>替换为一下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># This file only needs to list configuration variables that deviate</span><br><span class="line"># from the default values. See /usr/share/doc/polipo/examples/config.sample</span><br><span class="line"># and "polipo -v" for variables you can tweak and further information.</span><br><span class="line">logSyslog = false</span><br><span class="line">logFile = "/var/log/polipo/polipo.log"</span><br><span class="line"></span><br><span class="line">socksParentProxy = "127.0.0.1:1080"</span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line"></span><br><span class="line">serverMaxSlots = 64</span><br><span class="line">serverSlots = 16</span><br><span class="line">serverSlots1 = 32</span><br><span class="line"></span><br><span class="line">proxyAddress = "0.0.0.0"</span><br><span class="line">proxyPort = 8123</span><br></pre></td></tr></table></figure><p>5、重启Polipo以及在终端使用代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/polipo restart</span><br><span class="line">export http_proxy="http://127.0.0.1:8123/"</span><br><span class="line">curl www.google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 即可在终端只用代理</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">unset http_proxy</span><br></pre></td></tr></table></figure><p>6、配置浏览器</p><p>对于不同的游览器，配置方法不同，所以在此我们可以直接修改全局网络。</p><p>打开setting -&gt; Network -&gt; Network Proxy : Method Manual</p><p>下面所有栏都设置为127.0.0.1端口：8123，并应用到全局。</p><p>7、日常使用</p><p>每天打开电脑的状态是：全局代理打开，shadowsocks客户端并没有启动，所以浏览器并不能连接网络。</p><p>如果不需要科学上网，只需要按照第6步把网络代理关掉。</p><p>如果需要科学上网，需要开启shadowsocks服务并且有时需要开启Polipo服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">screen python shadowsocksr/shadowsocks/local.py -c /etc/shadowsocks.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在screen模式下，ctrl+a，然后d(detach)，或者直接关闭当前terminal，该进程即在后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启polipo</span></span><br><span class="line">/etc/init.d/polipo restart</span><br></pre></td></tr></table></figure><h4 id="八、深度学习环境"><a href="#八、深度学习环境" class="headerlink" title="八、深度学习环境"></a>八、深度学习环境</h4><p>1、显卡驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看自己的显卡适合的驱动器版本号</span></span><br><span class="line">ubunut-drivers devices</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载原有驱动</span></span><br><span class="line">sudo apt-get remove --purge nvidia*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加ppa源到系统</span></span><br><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新源</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭图形界面</span></span><br><span class="line">sudo service lightdm stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 屏幕变黑，按下ctrl+alt+f1进入命令号界面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装独显驱动</span></span><br><span class="line">sudo apt-get install nvidia-xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否正确安装</span></span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>2、安装cuda</p><p>附：Tensorflow不同版本与CUDA和CUDNN版本对应关系</p><table><thead><tr><th>版本</th><th>Python</th><th>CUDA</th><th>cuDNN</th></tr></thead><tbody><tr><td>tensorflow_gpu-1.11.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.10.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.9.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.8.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.7.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.6.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.5.0</td><td>3.5-3.6</td><td>9</td><td>7</td></tr><tr><td>tensorflow_gpu-1.4.0</td><td>3.5-3.6</td><td>8</td><td>6</td></tr><tr><td>tensorflow_gpu-1.3.0</td><td>3.5-3.6</td><td>8</td><td>6</td></tr><tr><td>tensorflow_gpu-1.2.0</td><td>3.5-3.6</td><td>8</td><td>5.1</td></tr><tr><td>tensorflow_gpu-1.1.0</td><td>3.5</td><td>8</td><td>5.1</td></tr><tr><td>tensorflow_gpu-1.0.0</td><td>3.5</td><td>8</td><td>5.1</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖（是否有用及必须未验证）</span></span><br><span class="line">sudo apt-get install mesa-common-dev</span><br><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure><p>到<a href="https://developer.nvidia.com/cuda-toolkit-archive" rel="external nofollow noopener noreferrer" target="_blank">NVIDIA官网</a>下载相应的CUDA版本的run文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo sh cudaXXXXXX.run</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### Note: 在询问是否安装NVIDIA驱动的时候选择no，其他默认</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line">export PATH=/usr/local/cuda-8.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 验证cuda成功安装（可选）</span></span><br><span class="line">cd /usr/local/cuda-8.0/samples</span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有make，先安装make</span></span><br><span class="line">sudo apt-get install cmake</span><br><span class="line">sudo make -j</span><br><span class="line">cd ./bin/x86_64/linux/release</span><br><span class="line">./deviceQuery </span><br><span class="line"><span class="meta">#</span><span class="bash">如果结果中显示了NVIDIA显卡的相关信息，最后能看到Result = PASS就算安装成功</span></span><br></pre></td></tr></table></figure><p>3、安装cuDNN</p><p>登录<a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey" rel="external nofollow noopener noreferrer" target="_blank">NVIDIA账号</a>下载对应cuDNN版本（cuDNN vX.0 Library for xxx）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line">tar -zxvf cudnn-xxx.tgz</span><br><span class="line">cd cuda</span><br><span class="line">sudo cp /include/cudnn.h /usr/local/cudaxxx/include/</span><br><span class="line">cd ../lib64</span><br><span class="line">sudo cp lib* /usr/local/cudaxxx/lib64</span><br><span class="line"></span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/cudnn.h </span><br><span class="line">sudo chmod a+r /usr/local/cuda/lib64/libcudnn*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新软连接</span></span><br><span class="line">cd /usr/local/cuda/lib64/ </span><br><span class="line">sudo rm -rf libcudnn.so libcudnn.so.7   #删除原有动态文件，版本号注意变化，可在cudnn的lib64文件夹中查看   </span><br><span class="line">sudo ln -s libcudnn.so.7.0.2 libcudnn.so.7  #生成软衔接（注意这里要和自己下载的cudnn版本对应，可以在/usr/local/cuda/lib64下查看自己libcudnn的版本）</span><br><span class="line">sudo ln -s libcudnn.so.7 libcudnn.so #生成软链接</span><br><span class="line">sudo ldconfig -v #立刻生效</span><br></pre></td></tr></table></figure><h4 id="九、相关资源"><a href="#九、相关资源" class="headerlink" title="九、相关资源"></a>九、相关资源</h4><p><a href="https://www.jianshu.com/p/893d622d1b5a" rel="external nofollow noopener noreferrer" target="_blank">搭建深度学习平台</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下记录一下Ubuntu的配置流程，持续更新&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;环境：ubuntu 16.04.6 Desktop&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一、更新apt源&quot;&gt;&lt;a href=&quot;#一、更新apt源&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="环境配置" scheme="https://zhaoziwen.com.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="ubuntu" scheme="https://zhaoziwen.com.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Largest Rectangle in Histogram &amp; Maximal Rectangle</title>
    <link href="https://zhaoziwen.com.cn/archives/f63981d1.html"/>
    <id>https://zhaoziwen.com.cn/archives/f63981d1.html</id>
    <published>2019-03-20T17:08:23.000Z</published>
    <updated>2019-06-05T07:59:29.938Z</updated>
    
    <content type="html"><![CDATA[<p>这两题在LeetCode上位置临近，它们之间存在一定的关联</p><blockquote><p>[LeetCode] 84. Largest Rectangle in Histogram</p><p>Given n non-negaive integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/histogram-1.png" alt="histogra" title>                </div>                <div class="image-caption">histogra</div>            </figure></blockquote><blockquote><p>Above is a histogram where width of each bar is 1, given height = [2, 1, 5, 6, 2, 3].</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/histogram_area.png" alt="histogram_area" title>                </div>                <div class="image-caption">histogram_area</div>            </figure></blockquote><blockquote><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><p>Example:</p><p>Input: [2, 1, 5, 6, 2, 3]</p><p>Output: 10</p></blockquote><p>最初的想法是用DP，但是一直没能找出状态转移公式。所以这题的方法是遍历数组，每找到一个局部峰值(只要当前值大于紧随其后的值，就可以视为局部峰值)，就向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。至于为什么是局部峰值，可以这样来证明：如果不是局部峰值，意味着紧随其后的值大于等于当前值，那如果最大面积包括当前值，那毫无疑问也包括随后的值。所以目标区域一定结束在局部峰值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pruning optimize</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; height.size() &amp;&amp; height[i] &lt;= height[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> minH = height[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                minH = min(minH, height[j]);</span><br><span class="line">                <span class="keyword">int</span> area = minH * (i - j + <span class="number">1</span>);</span><br><span class="line">                res = max(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>[LeetCode] 85. Maximal Rectangle</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>Example:</p><p>Input:</p><p>[</p><p>​    [“1”,”0”,”1”,”0”,”0”],</p><p>​    [“1”,”0”,”1”,”1”,”1”],</p><p>​    [“1”,”1”,”1”,”1”,”1”],</p><p>​    [“1”,”0”,”0”,”1”,”0”]</p><p>]</p><p>Output: 6</p></blockquote><p>这题确实对目前的我来讲过于复杂，一开始没有任何头绪，尝试往DP方向上靠，但是感觉转移方程过于复杂。后来找到了一种较为简单的方法。</p><p>对目标2D数组每一行进行切分，每一层向上都可以看做一个直方图，输入矩阵有多少行，就可以形成多少个直方图，每个直方图都调用上题的方法，就可以得到矩形面积。其中构造直方图的方法为：对于每一个点，如果是0，则赋0；如果是1，就赋之前的值(上一层)加1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">            height.resize(matrix[i].size());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size(); ++j) &#123;</span><br><span class="line">                height[j] = matrix[i][j] == <span class="string">'0'</span> ? <span class="number">0</span> : (<span class="number">1</span> + height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, largestRectangleArea(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || height[s.top()] &lt;= height[i]) s.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res = max(res, height[tmp] * (s.empty() ? i : (i - s.top() - <span class="number">1</span>)));</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，这题仍然可以用DP的方法，不过看起来比较复杂，所以先暂时留着，附上链接，之后总结一下DP的流程只有再总结一下。</p><p><a href="https://blog.csdn.net/maxiaotiaoti/article/details/62230381" rel="external nofollow noopener noreferrer" target="_blank">DP思路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两题在LeetCode上位置临近，它们之间存在一定的关联&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[LeetCode] 84. Largest Rectangle in Histogram&lt;/p&gt;
&lt;p&gt;Given n non-negaive integers repre
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>用户数据报协议UDP详解</title>
    <link href="https://zhaoziwen.com.cn/archives/6fb700a9.html"/>
    <id>https://zhaoziwen.com.cn/archives/6fb700a9.html</id>
    <published>2019-03-19T17:38:21.000Z</published>
    <updated>2019-06-07T10:29:32.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>UDP只在IP数据报服务之上增加了复用、分用以及差错检测的功能。UDP的主要特点</p><ol><li><strong>无连接</strong>。发送数据之前不需要建立连接，同时意味着减少了开销和发送前的时延。</li><li><strong>尽最大努力交付</strong>，即不保证可靠交付。意味着主机不需要维持复杂的链接状态表。</li><li><strong>面向报文</strong>。UDP对应用层下发的报文既不合并也不拆分，只添加首部后交给IP层。</li><li><strong>没有拥塞控制</strong>。意味着网络出现的拥塞不会使主机发送频率降低。</li><li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li><strong>UPD首部开销小</strong>。只有8个字节，TCP首部20字节。</li></ol><h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><p>UDP首部只有8个字节，由四个字段组成，每个字段两个字节。各字段意义如下：</p><ol><li><strong>源端口</strong>。在需要对方回信时使用。不需要可用全0。</li><li><strong>目的端口</strong>。在终点交付报文是必须使用。</li><li><strong>长度</strong>。UDP用户数据报的长度，最小值为8（首部）。</li><li><strong>检验和</strong>。检测UDP用户数据报在传输中是否有错。有错即丢弃。</li></ol><p>当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交到最后的终点——应用程序。如果接收方UDP发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网际控制报文ICMP发送“端口不可达”差错报文给发送方。虽然UDP需要使用到端口号，但由于UDP的通信是无连接的，因此不需要套接字。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://hexo-blog-1252103983.cos.ap-guangzhou.myqcloud.com/2019/06/03/u=925851693,2714828517-fm=26-gp=0.png" alt="u=925851693,2714828517-fm=26-gp=0" title>                </div>                <div class="image-caption">u=925851693,2714828517-fm=26-gp=0</div>            </figure><p>UDP在计算检验和时，在UDP用户数据报之前增加12个字节的伪首部（并不是真正的首部，既不向下传送也不向上递交，仅仅用于计算检验和）</p><p>计算检验和步骤：</p><ol><li>把伪首部添加到UDP上；</li><li>计算初始是需要将检验和字段添零；</li><li>把所有位划分为16位（2字节）的字</li><li>把所有16位的字相加，如果遇到进位，则将高于16位的进位部分的值加到最低位上</li><li>将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;UDP只在IP数据报服务之上增加了复用、分用以及差错检测的功能。UDP的主要特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;无连接&lt;/str
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zhaoziwen.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UDP" scheme="https://zhaoziwen.com.cn/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>Unique Binary Search Trees</title>
    <link href="https://zhaoziwen.com.cn/archives/20d2cb13.html"/>
    <id>https://zhaoziwen.com.cn/archives/20d2cb13.html</id>
    <published>2019-03-19T16:54:11.000Z</published>
    <updated>2019-06-05T07:59:29.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 96. Given n, how many structurally unique BST’s that store values 1 … n ?</p><p>Example:</p><p>Input: 3</p><p>Output: 5</p><p>Explanation:</p><p>Given n = 3, there are a total of 5 unique BST’s:</p></blockquote><p>思路一递归：</p><p>空树和只有根结点时，也为BST。对于一点i，当其为根结点时，左子树的节点的个数为i-1（1, … , i-1），右子树的个数为n-i（i+1, … , n）。对于一个根来说，唯一二叉树的个数为左子树节点的个数乘以右子树的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            sum+=numTrees(i<span class="number">-1</span>)*numTrees(n-i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路二动态规划：</p><p>卡特兰数的递推公式：</p><p>$$C_{0} = 1 \ and \  C_{n+1} = \sum_{i=0}^{n}C_{i}C_{n-i} \ for \ n\geq 0.$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumNode(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        sumNode[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        sumNode[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)　　<span class="comment">//j符合条件时，最大为i-1，对照公式</span></span><br><span class="line">                sumNode[i]+=sumNode[j]*sumNode[i-j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumNode[n];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 96. Given n, how many structurally unique BST’s that store values 1 … n ?&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Input: 3&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Word Search 之 DFS</title>
    <link href="https://zhaoziwen.com.cn/archives/fc1bc906.html"/>
    <id>https://zhaoziwen.com.cn/archives/fc1bc906.html</id>
    <published>2019-03-19T16:36:42.000Z</published>
    <updated>2019-06-05T07:59:29.956Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 79. Word Search</p><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:</p><p>board = </p><p>[</p><p>​    [‘A’, ‘B’, ‘C’, ‘E’]</p><p>​    [‘S’, ‘F’, ‘C’, ‘S’]</p><p>​    [‘A’, ‘D’, ‘E’, ‘E’]</p><p>]</p><p>Given word = “ABCCED”, return true.</p><p>Given word = “SEE”, return true.</p><p>Given word = “ABCB”, return false.</p></blockquote><p>这题不算难，但是没有想到深度优先遍历DFS，所以有点无从下手。</p><p>具体看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.empty() || board[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (search(board, word, <span class="number">0</span>, i, j, visited)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> idx, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || visited[i][j] || board[i][j] != word[idx]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = search(board, word, idx + <span class="number">1</span>, i - <span class="number">1</span>, j, visited) </span><br><span class="line">                 || search(board, word, idx + <span class="number">1</span>, i + <span class="number">1</span>, j, visited)</span><br><span class="line">                 || search(board, word, idx + <span class="number">1</span>, i, j - <span class="number">1</span>, visited)</span><br><span class="line">                 || search(board, word, idx + <span class="number">1</span>, i, j + <span class="number">1</span>, visited);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 79. Word Search&lt;/p&gt;
&lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;/p&gt;
&lt;p&gt;The word can be c
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Edit Distance 编辑距离</title>
    <link href="https://zhaoziwen.com.cn/archives/cf1b7ee3.html"/>
    <id>https://zhaoziwen.com.cn/archives/cf1b7ee3.html</id>
    <published>2019-03-18T17:01:23.000Z</published>
    <updated>2019-06-05T07:59:29.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 72. Edit Distance</p><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em></p><p>You have the following 3 operations permitted on a word:</p><ol><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><p>Example:</p><p>Input: word1 = “horse”, word2 = “ros”</p><p>Output: 3</p><p>Explanation:</p><p>horse -&gt; rorse</p><p>rorse -&gt; rose</p><p>rose -&gt; ros</p></blockquote><p>这道题一开始是能想到实用动态规划的，但是题目理解有点问题，所以没能推出DP的初始状态和状态转移方程。</p><p>思路：</p><p>这里需要维护一个二维DP数组，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。其中初始状态该二维数组第一行第一列很容易赋值，因为其中一个为空串，所以值为另一个字符串的长度。</p><p>以下用word1=”bbc”, word2=”abcd”为例：</p><table><thead><tr><th align="center"></th><th align="center">null</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">d</th></tr></thead><tbody><tr><td align="center">null</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center">b</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">b</td><td align="center">2</td><td align="center">2</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">c</td><td align="center">3</td><td align="center">3</td><td align="center">2</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>所以状态转移方程为：</p><p>if word1[i-1] == word2[j-1]            dp[i][j] = dp[i-1][j-1]</p><p>else                                dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = word1.size(), n2 = word2.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; ++i) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 72. Edit Distance&lt;/p&gt;
&lt;p&gt;Given two words &lt;em&gt;word1&lt;/em&gt; and &lt;em&gt;word2&lt;/em&gt;, find the minimum number of operations
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Longest_valid_parentheses</title>
    <link href="https://zhaoziwen.com.cn/archives/102deb8e.html"/>
    <id>https://zhaoziwen.com.cn/archives/102deb8e.html</id>
    <published>2019-03-13T15:58:12.000Z</published>
    <updated>2019-06-05T07:59:29.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 32. Longest Valid Parentheses</p></blockquote><blockquote><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid parentheses substring.</p></blockquote><blockquote><p>Example:</p></blockquote><blockquote><p>Input: “)()()”</p></blockquote><blockquote><p>Output: 4</p></blockquote><p>思路一：动态规划</p><p>dp[i]表示以当前位置为终点的最长长度，则只能在“)”处更新：</p><p>如果s[i-1-dp[i-1]]==’(‘，则说明当前位置可以和i-1-dp[i-1]位置匹配，dp[i] = dp[i-1]+2；</p><p>然后还要加上匹配位置之前的最长长度dp[i]+=dp[i-dp[i]]；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        s = <span class="string">')'</span> + s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>]] == <span class="string">'('</span>) dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                dp[i] += dp[i-dp[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            result = max(result,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路二：栈</p><p>定义start变量记录合法括号串的起始位置；</p><p>遍历字符串；</p><p>如果遇到左括号，则将当前下标压入栈；</p><p>如果遇到右括号：</p><p>​    如果当前栈为空，则将下一个坐标位置记录到start</p><p>​    如果不为空，则将栈顶元素取出：</p><p>​        此时若栈为空，则更新“前面的结果”和“i-start+1”中的较大值</p><p>​        否则更新“前面的结果”和“i-栈顶元素”中的较大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) m.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m.empty()) start = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    m.pop();</span><br><span class="line">                    res = m.empty() ? max(res, i - start + <span class="number">1</span>) : max(res, i - m.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 32. Longest Valid Parentheses&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string containing just the characters ‘(‘
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>递归之生成括号</title>
    <link href="https://zhaoziwen.com.cn/archives/7e2dbf13.html"/>
    <id>https://zhaoziwen.com.cn/archives/7e2dbf13.html</id>
    <published>2019-03-12T15:48:48.000Z</published>
    <updated>2019-06-05T07:59:29.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[LeetCode] 22. Generate Parentheses</p><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><p>[</p><p>​    “((()))”</p><p>​    “(()())”</p><p>​    “()(())”</p><p>​    “()()()”</p><p>]</p></blockquote><p>和合法的情况下，任意时刻，左括号个数要大于等于右括号个数</p><p>1、当left个数大于right个数，非常情况，返回即可</p><p>2、left和right都等于0，临时变量中左右括号个数相等，所以将临时变量的值存入res中</p><p>3、其余情况下，先放左括号，再放右括号，然后递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        generateParenthesisDFS(n, n, <span class="string">""</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateParenthesisDFS</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">string</span> out, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) res.push_back(out);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; <span class="number">0</span>) generathesisDFS(left - <span class="number">1</span>, right, out + <span class="string">'('</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(right &gt; <span class="number">0</span>) generathesisDFS(left, right - <span class="number">1</span>, out + <span class="string">')'</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊思路：找左括号，每找到一个左括号，就在其后面加一个完整的括号，最后再在开头加一个()，但是有时候会重复出现，即用set数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) t.insert(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pre = generateParenthesis(n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a:pre) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                        a.insert(a.begin() + i + <span class="number">1</span>, <span class="string">'('</span>);</span><br><span class="line">                        a.insert(a.begin() + i + <span class="number">2</span>, <span class="string">')'</span>);</span><br><span class="line">                        t.insert(a);</span><br><span class="line">                        a.erase(a.begin() + i + <span class="number">1</span>, a.begin() + i + <span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t.insert(<span class="string">"()"</span> + a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(t.begin(), t.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;[LeetCode] 22. Generate Parentheses&lt;/p&gt;
&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of we
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Median_of_two_sorted_arrays</title>
    <link href="https://zhaoziwen.com.cn/archives/9787c008.html"/>
    <id>https://zhaoziwen.com.cn/archives/9787c008.html</id>
    <published>2019-03-11T13:51:00.000Z</published>
    <updated>2019-06-05T07:59:29.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Median-of-two-sorted-arrays"><a href="#Median-of-two-sorted-arrays" class="headerlink" title="Median of two sorted arrays"></a>Median of two sorted arrays</h3><p>核心是将原问题转变成寻找第k小数的问题（假设两个原序列升序排列）</p><p>首先假设数组A和B的元素个数都大于k/2，比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。</p><p>1、A[k/2-1]&lt;B[k/2-1]，表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中，所以我们抛弃它。</p><p>2、A[k/2-1]&gt;B[k/2-1]，同上</p><p>3、A[k/2-1]=B[k/2-1]，这个数即第K小的数</p><blockquote><p>[LeetCode] 4. Median of Two Sorted Arrays</p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).</p><p>Example:</p><p>nums1 = [1, 3]</p><p>nums2 = [2]</p><p>The midian is 2.0</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line"><span class="keyword">if</span> (total &amp; <span class="number">0x1</span>)</span><br><span class="line"><span class="keyword">return</span> findKth(nums1, m, nums2, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> num1 = findKth(nums1, m, nums2, n, total / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">double</span> num2 = findKth(nums1, m, nums2, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> (num1 + num2) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(b, n, a, m, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pa = min(k/<span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">int</span> pb = k - pa;</span><br><span class="line">        <span class="keyword">if</span>(a[pa - <span class="number">1</span>] &lt; b[pb - <span class="number">1</span>]) &#123;</span><br><span class="line">            a.erase(a.begin(), a.begin() + pa);</span><br><span class="line">            <span class="keyword">return</span> findKth(a, m-pa, b, n, k-pa);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[pa<span class="number">-1</span>] &gt; b[pb - <span class="number">1</span>]) &#123;</span><br><span class="line">            b.erase(b.begin(), b.begin() + pb);</span><br><span class="line">            <span class="keyword">return</span> findKth(a, m, b, n-pb, k-pb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[pa - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常规方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span> = merge(nums1, nums2);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)(<span class="built_in">array</span>[(m+n<span class="number">-1</span>)/<span class="number">2</span>]+<span class="built_in">array</span>[(m+n)/<span class="number">2</span>]))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> m = A.size();</span><br><span class="line">        <span class="keyword">int</span> n = B.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt;= B[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(A[i]);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(B[j]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(B[j]);</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(A[i]);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Median-of-two-sorted-arrays&quot;&gt;&lt;a href=&quot;#Median-of-two-sorted-arrays&quot; class=&quot;headerlink&quot; title=&quot;Median of two sorted arrays&quot;&gt;&lt;/a&gt;Media
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>String_rotate</title>
    <link href="https://zhaoziwen.com.cn/archives/a9dfa5b.html"/>
    <id>https://zhaoziwen.com.cn/archives/a9dfa5b.html</id>
    <published>2019-03-10T07:39:15.000Z</published>
    <updated>2019-06-05T07:59:29.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串翻转与旋转"><a href="#字符串翻转与旋转" class="headerlink" title="字符串翻转与旋转"></a>字符串翻转与旋转</h3><h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><p>除了常规思路的左右位置对调，至此提供一种新的思路，用以解决其他特定环境下的相关问题。</p><p>利用迭代的思路对需要处理的字符串两边整体对换直到只有一位，如对于一个8位数字abcdefgh来讲，处理过程如下：</p><p>abcdefgh -&gt; efghabcd -&gt; ghefcdab -&gt; hgfedcba</p><p>例如：</p><blockquote><p>[LeetCode] 190. Reverse Bits</p><p>Reverse bits of a given 32 bits unsigned integer.</p><p>Example :</p><p>Input: 00000010100101000001111010011100</p><p>Output: 00111001011110000010100101000000</p></blockquote><p>常规思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        res |= (((n &gt;&gt; i) &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">32</span> - i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>类似翻转字符串的方法，思路是先把前n-k个字符翻转一下，再把后k个字符翻转一下，最后再把整个数组翻转一下</p><p>例如：</p><blockquote><p>[LeetCode] 189. Rotate Array</p><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p><p>Example:</p><p>Input: [1,2,3,4,5,6,7] and k = 3</p><p>Output: [5,6,7,1,2,3,4]</p></blockquote><p>常规思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; k &lt; nums.size(); i++) &#123;</span><br><span class="line">            nums[(i + k) % nums.size()] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串翻转与旋转&quot;&gt;&lt;a href=&quot;#字符串翻转与旋转&quot; class=&quot;headerlink&quot; title=&quot;字符串翻转与旋转&quot;&gt;&lt;/a&gt;字符串翻转与旋转&lt;/h3&gt;&lt;h4 id=&quot;翻转&quot;&gt;&lt;a href=&quot;#翻转&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://zhaoziwen.com.cn/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://zhaoziwen.com.cn/tags/leetcode/"/>
    
  </entry>
  
</feed>
