[{"title":"hexo博客搭建","date":"2019-06-03T03:51:44.000Z","path":"2019/06/03/start-hexo/","text":"安装NodeJS和NPM1curl --silent --location https://rpm.nodesource.com/setup_10.x | sudo bash - 1yum install -y nodejs 安装Nginx1vim /etc/yum.repos.d/nginx.repo 将以下内容拷贝进去 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 安装 1yum install nginx -y 由于centos默认自带防火墙，所以这里需要关闭防火墙才能访问 123systemctl start firewalld.service #启动firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 安装git并设置1234yum install git #安装gitssh-keygen -t rsa -b 4096 -C \"xxxxx@xxx.com\" #生成公钥cat ~/.ssh/id_rsa.pub #查看公钥，并把它复制到github账户中 拉取仓库并配置nginx123git clone ...vim /etc/nginx/conf.d/hexo.conf 写入下列相应配置 12345678server &#123; listen 80; server_name blog.zhaoziwen.com.cn; location / &#123; root /root/zhaowenzi.github.io; index index.html; &#125;&#125; 重启生效 1nginx -s reload 修改nginx权限 1234vim /etc/nginx/nginx.conf#将user nginx; 改为 user root; #然后再次重启 配置webhooks自动更新博客安装依赖库 1npm install -g github-webhook-handler 配置webhook.js 1vim webhooks.js 将下面的配置写入上面的文件 12345678910111213141516171819202122232425262728293031var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/webhooks_push', secret: '***' &#125;)// 上面的 secret 保持和 GitHub 后台设置的一致function run_cmd(cmd, args, callback) &#123; var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function(buffer) &#123; resp += buffer.toString(); &#125;); child.stdout.on('end', function() &#123; callback (resp) &#125;);&#125;http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(6666)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); run_cmd('sh', ['./deploy.sh'], function(text)&#123; console.log(text) &#125;);&#125;) 配置./deploy.sh 1vim deploy.sh 写入 12cd ~/zhaowenzi.github.iogit pull 用pm2来实现守护进程 1npm install pm2 --global 通过pm2启动webhooks.js 1pm2 start webhooks.js 全站HTTPS通过Certbot傻瓜操作 123wget https://dl.eff.org/certbot-autochmod a+x certbot-autosudo ./certbot-auto --nginx 通过crontab定时任务自动更新 1crontab -e 添加下面这条命令 10 0 * * 0 /root/certbot-auto renew 即每周日的0点0分执行更新证书的命令","tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zhaoziwen.com.cn/tags/hexo/"}]},{"title":"Hello World","date":"2019-06-02T16:01:41.400Z","path":"2019/06/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"基本TCP套接字编程","date":"2019-04-13T11:51:39.000Z","path":"2019/04/13/basic-tcp-socket-code/","text":"基础源码(请求日期和时间)客户端12345678910111213141516171819202122232425262728293031323334#include \"unp.h\"intmain(int argc, char **argv)&#123; int sockfd, n; char recvline[MAXLINE + 1]; struct sockaddr_in servaddr; if (argc != 2) err_quit(\"usage: a.out &lt;IPaddress&gt;\"); if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) err_sys(\"socket error\"); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13); /* daytime server */ if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) err_quit(\"inet_pton error for %s\", argv[1]); if (connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr)) &lt; 0) err_sys(\"connect error\"); while ( (n = read(sockfd, recvline, MAXLINE)) &gt; 0) &#123; recvline[n] = 0; /* null terminate */ if (fputs(recvline, stdout) == EOF) err_sys(\"fputs error\"); &#125; if (n &lt; 0) err_sys(\"read error\"); exit(0);&#125; 服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include \"unp.h\"#include &lt;time.h&gt;#include &lt;unistd.h&gt;intmain(int argc, char **argv)&#123; int listenfd, connfd; socklen_t len; struct sockaddr_in servaddr, cliaddr; char buff[MAXLINE]; time_t ticks; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(13); /* daytime server */ Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); // 阻塞服务器 // for ( ; ; ) &#123; // len = sizeof(cliaddr); // connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len); // sleep(5); // printf(\"connection from %s, port %d\\n\", // Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, sizeof(buff)), // ntohs(cliaddr.sin_port)); // ticks = time(NULL); // snprintf(buff, sizeof(buff), \"%.24s\\r\\n\", ctime(&amp;ticks)); // Write(connfd, buff, strlen(buff)); // Close(connfd); // &#125; // 并发服务器 pid_t pid; for(;;) &#123; len = sizeof(cliaddr); connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len); if((pid = Fork()) == 0) &#123; Close(listenfd); sleep(5); printf(\"connection from %s, port %d\\n\", Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, sizeof(buff)), ntohs(cliaddr.sin_port)); ticks = time(NULL); snprintf(buff, sizeof(buff), \"%.24s\\r\\n\", ctime(&amp;ticks)); Write(connfd, buff, strlen(buff)); Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125; 部分函数解释socket函数执行网络I/O的进程必须做的第一件事情 12#include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol); family常值： ​ IPv4协议：AF_INET ​ IPv6协议：AF_INET6 type常值： ​ 字节流套接字：SOCK_STREAM ​ 数据报套接字：SOCK_DGRAM protocol常值： ​ TCP传输协议：IPPROTO_CP ​ UDP传输协议：IPPROTO_UDP 返回值： ​ 成功时返回一个小的非负整数值，称为套接字描述符，简称sockfd connect函数TCP客户用connect函数来建立与TCP服务器的连接 12#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); 出错返回情况： 1、一定时间内没有收到SYN分节的响应，返回ETIMEDOUT错误 2、若对SYN的响应是RST，表明该服务器主机在指定端口上没有进程在等待与之连接。返回ECONNREFUSED错误 3、客户发出的SYN在中间的某个路由器上引发了一个”destination unreachable”ICMP错误。若在一段时间内仍未收到响应，则返回EHOSTUNREACH或ENETUNREACH错误 bind函数把一个本地协议地址赋予一个套接字 12#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *myaddr, socken_t addrlen); 对于IPv4，同配地址由常值INADDR_ANY来指定，其值一般为0 对于IPv6，因为128位的IPv6地址是存放在一个结构中的。(在C语言中，赋值语句的右边无法表示常值结构)，则可以改写为 12struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; 系统预先分配in6addr_any变量并将其初始化为常值IN6ADDR_ANY_INIT。头文件&lt;netinet/in.h&gt;中含有in6addr_any的extern声明(0的网络字节序和主机字节序一样，所以没用htonl) listen函数listen函数仅由TCP服务器调用 12#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); 第二个参数规定了内核应该为相应套接字排队的最大连接个数 该函数在socket和bind之后调用，在accept之前调用 accept函数accept函数由TCP服务器调用，用于从已完成连接队列头返回下一个已完成连接。如果为空，则投入睡眠 12#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); 它的第一个参数为监听套接字描述符，返回值为已连接套接字描述符 fork和exec函数12#include &lt;unistd.h&gt;pid_t fork(void); fork函数调用一次，返回两次。在调用进程(父进程)返回一次，返回值为新派生的进程(子进程)的进程ID号。在子进程又返回一次，返回值为0 并发服务器典型的并发服务器程序轮廓： 123456789101112131415pid_t pid;int listenfd, connfd;listenfd = Socket(...);Bind(listenfd, ...);Listen(listenfd, LISTENQ);for( ; ; ) &#123; connfd = Accept(listenfd, ...); if((pid = Fork()) == 0) &#123; Close(listenfd); doit(connfd); Close(connfd); exit(0); &#125; Close(connfd);&#125; close函数12#include &lt;unistd.h&gt;int close(int sockfd); getsockname和getpeername函数返回与某个套接字关联的本地协议地址(getsockname)或者返回与某个套接字关联的外地协议地址(getpeername) 123#include &lt;sys/socket.h&gt;int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); 例子：获取套接字的地址族 123456789#include \"unp.h\"int sockfd_to_family(int sockfd) &#123; struct sockaddr_storage ss; socken_t len; len = sizeof(ss); if(getsockname(sockfd, (SA *) &amp;ss, &amp;len) &lt; 0) return(-1); return(ss.ss_family);&#125;","tags":[{"name":"tcp","slug":"tcp","permalink":"https://blog.zhaoziwen.com.cn/tags/tcp/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.zhaoziwen.com.cn/tags/计算机网络/"},{"name":"UNIX网络编程","slug":"UNIX网络编程","permalink":"https://blog.zhaoziwen.com.cn/tags/UNIX网络编程/"}]},{"title":"Best Time to Buy and Sell Stock with Cooldown","date":"2019-04-01T14:57:33.000Z","path":"2019/04/01/best-time-to-buy-and-sell-stock-with-cooldown/","text":"[LeetCode] 309. Say you have an array for which the $i^{th}$element is the price of a given stock on day $i$. Design an algorithm to find the maximum profit. You may complete as many transactions as you like(ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time(ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cool down 1 day) Example: Input: [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 这里的动态规划问题跟之前的稍有不同。 当前买卖股票的行为会受到之前日期买卖股票行为的影响。对一天的状态有：买入bug，卖出sell，冷却cooldown。 但是对于这一天是否持股只有两种状态：持股状态buy，没有持股状态sell, cooldown。 对于当天持股状态时，至当天为止的最大利润有两种可能： 今天没有买入，跟昨天持股状态一样 今天买入，昨天是冷却期，利润是前天卖出股票时得到的利润减去今天股票的价钱。 二者取最大值。 对于当天未持股状态，至当天为止的最大利润也有两种情况： 今天没有卖出，跟昨天未持股状态一样 昨天持有股票，今天卖出了，例如是昨天持有股票时候的利润加上今天股票的价钱 二者取最大值 直至最后一天的状态应该是卖出状态。最终利润是sell[n-1]。 状态转移方程：$$sell[i] = max(sell[i-1], buy[i-1]+price[i]);$$$$buy[i] = max(buy[i-1], sell[i-1]-price[i]);$$ 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 0) return 0; int pre_bug = 0, pre_sell = 0, buy = -prices[0], sell = 0; for(auto price:prices) &#123; pre_buy = buy; buy = max(pre_buy, pre_sell-price); // 此处的buy已经指到下一个，pre_buy更新为之前的buy，现在的buy的前一个，但是pre_sell没有更新，为现在的buy的前一个的前一个 pre_sell = sell; sell = max(pre_sell, pre_buy+price); &#125; return sell; &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.zhaoziwen.com.cn/tags/leetcode/"}]}]